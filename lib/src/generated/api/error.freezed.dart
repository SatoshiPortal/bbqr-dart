// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'error.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$EncodeError {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(String field0) compressionError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(String field0)? compressionError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String field0)? compressionError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EncodeError_Empty value) empty,
    required TResult Function(EncodeError_CompressionError value)
        compressionError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EncodeError_Empty value)? empty,
    TResult? Function(EncodeError_CompressionError value)? compressionError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EncodeError_Empty value)? empty,
    TResult Function(EncodeError_CompressionError value)? compressionError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EncodeErrorCopyWith<$Res> {
  factory $EncodeErrorCopyWith(
          EncodeError value, $Res Function(EncodeError) then) =
      _$EncodeErrorCopyWithImpl<$Res, EncodeError>;
}

/// @nodoc
class _$EncodeErrorCopyWithImpl<$Res, $Val extends EncodeError>
    implements $EncodeErrorCopyWith<$Res> {
  _$EncodeErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$EncodeError_EmptyImplCopyWith<$Res> {
  factory _$$EncodeError_EmptyImplCopyWith(_$EncodeError_EmptyImpl value,
          $Res Function(_$EncodeError_EmptyImpl) then) =
      __$$EncodeError_EmptyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EncodeError_EmptyImplCopyWithImpl<$Res>
    extends _$EncodeErrorCopyWithImpl<$Res, _$EncodeError_EmptyImpl>
    implements _$$EncodeError_EmptyImplCopyWith<$Res> {
  __$$EncodeError_EmptyImplCopyWithImpl(_$EncodeError_EmptyImpl _value,
      $Res Function(_$EncodeError_EmptyImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$EncodeError_EmptyImpl extends EncodeError_Empty {
  const _$EncodeError_EmptyImpl() : super._();

  @override
  String toString() {
    return 'EncodeError.empty()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$EncodeError_EmptyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(String field0) compressionError,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(String field0)? compressionError,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String field0)? compressionError,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EncodeError_Empty value) empty,
    required TResult Function(EncodeError_CompressionError value)
        compressionError,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EncodeError_Empty value)? empty,
    TResult? Function(EncodeError_CompressionError value)? compressionError,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EncodeError_Empty value)? empty,
    TResult Function(EncodeError_CompressionError value)? compressionError,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class EncodeError_Empty extends EncodeError {
  const factory EncodeError_Empty() = _$EncodeError_EmptyImpl;
  const EncodeError_Empty._() : super._();
}

/// @nodoc
abstract class _$$EncodeError_CompressionErrorImplCopyWith<$Res> {
  factory _$$EncodeError_CompressionErrorImplCopyWith(
          _$EncodeError_CompressionErrorImpl value,
          $Res Function(_$EncodeError_CompressionErrorImpl) then) =
      __$$EncodeError_CompressionErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$EncodeError_CompressionErrorImplCopyWithImpl<$Res>
    extends _$EncodeErrorCopyWithImpl<$Res, _$EncodeError_CompressionErrorImpl>
    implements _$$EncodeError_CompressionErrorImplCopyWith<$Res> {
  __$$EncodeError_CompressionErrorImplCopyWithImpl(
      _$EncodeError_CompressionErrorImpl _value,
      $Res Function(_$EncodeError_CompressionErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$EncodeError_CompressionErrorImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$EncodeError_CompressionErrorImpl extends EncodeError_CompressionError {
  const _$EncodeError_CompressionErrorImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'EncodeError.compressionError(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EncodeError_CompressionErrorImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EncodeError_CompressionErrorImplCopyWith<
          _$EncodeError_CompressionErrorImpl>
      get copyWith => __$$EncodeError_CompressionErrorImplCopyWithImpl<
          _$EncodeError_CompressionErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(String field0) compressionError,
  }) {
    return compressionError(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(String field0)? compressionError,
  }) {
    return compressionError?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String field0)? compressionError,
    required TResult orElse(),
  }) {
    if (compressionError != null) {
      return compressionError(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EncodeError_Empty value) empty,
    required TResult Function(EncodeError_CompressionError value)
        compressionError,
  }) {
    return compressionError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EncodeError_Empty value)? empty,
    TResult? Function(EncodeError_CompressionError value)? compressionError,
  }) {
    return compressionError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EncodeError_Empty value)? empty,
    TResult Function(EncodeError_CompressionError value)? compressionError,
    required TResult orElse(),
  }) {
    if (compressionError != null) {
      return compressionError(this);
    }
    return orElse();
  }
}

abstract class EncodeError_CompressionError extends EncodeError {
  const factory EncodeError_CompressionError(final String field0) =
      _$EncodeError_CompressionErrorImpl;
  const EncodeError_CompressionError._() : super._();

  String get field0;
  @JsonKey(ignore: true)
  _$$EncodeError_CompressionErrorImplCopyWith<
          _$EncodeError_CompressionErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SplitError {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() cannotFit,
    required TResult Function(int field0) maxSplitSizeTooLarge,
    required TResult Function() minSplitTooSmall,
    required TResult Function() invalidSplitRange,
    required TResult Function() invalidVersionRange,
    required TResult Function(EncodeError field0) encodeError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? cannotFit,
    TResult? Function(int field0)? maxSplitSizeTooLarge,
    TResult? Function()? minSplitTooSmall,
    TResult? Function()? invalidSplitRange,
    TResult? Function()? invalidVersionRange,
    TResult? Function(EncodeError field0)? encodeError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? cannotFit,
    TResult Function(int field0)? maxSplitSizeTooLarge,
    TResult Function()? minSplitTooSmall,
    TResult Function()? invalidSplitRange,
    TResult Function()? invalidVersionRange,
    TResult Function(EncodeError field0)? encodeError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SplitError_Empty value) empty,
    required TResult Function(SplitError_CannotFit value) cannotFit,
    required TResult Function(SplitError_MaxSplitSizeTooLarge value)
        maxSplitSizeTooLarge,
    required TResult Function(SplitError_MinSplitTooSmall value)
        minSplitTooSmall,
    required TResult Function(SplitError_InvalidSplitRange value)
        invalidSplitRange,
    required TResult Function(SplitError_InvalidVersionRange value)
        invalidVersionRange,
    required TResult Function(SplitError_EncodeError value) encodeError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SplitError_Empty value)? empty,
    TResult? Function(SplitError_CannotFit value)? cannotFit,
    TResult? Function(SplitError_MaxSplitSizeTooLarge value)?
        maxSplitSizeTooLarge,
    TResult? Function(SplitError_MinSplitTooSmall value)? minSplitTooSmall,
    TResult? Function(SplitError_InvalidSplitRange value)? invalidSplitRange,
    TResult? Function(SplitError_InvalidVersionRange value)?
        invalidVersionRange,
    TResult? Function(SplitError_EncodeError value)? encodeError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SplitError_Empty value)? empty,
    TResult Function(SplitError_CannotFit value)? cannotFit,
    TResult Function(SplitError_MaxSplitSizeTooLarge value)?
        maxSplitSizeTooLarge,
    TResult Function(SplitError_MinSplitTooSmall value)? minSplitTooSmall,
    TResult Function(SplitError_InvalidSplitRange value)? invalidSplitRange,
    TResult Function(SplitError_InvalidVersionRange value)? invalidVersionRange,
    TResult Function(SplitError_EncodeError value)? encodeError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SplitErrorCopyWith<$Res> {
  factory $SplitErrorCopyWith(
          SplitError value, $Res Function(SplitError) then) =
      _$SplitErrorCopyWithImpl<$Res, SplitError>;
}

/// @nodoc
class _$SplitErrorCopyWithImpl<$Res, $Val extends SplitError>
    implements $SplitErrorCopyWith<$Res> {
  _$SplitErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$SplitError_EmptyImplCopyWith<$Res> {
  factory _$$SplitError_EmptyImplCopyWith(_$SplitError_EmptyImpl value,
          $Res Function(_$SplitError_EmptyImpl) then) =
      __$$SplitError_EmptyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SplitError_EmptyImplCopyWithImpl<$Res>
    extends _$SplitErrorCopyWithImpl<$Res, _$SplitError_EmptyImpl>
    implements _$$SplitError_EmptyImplCopyWith<$Res> {
  __$$SplitError_EmptyImplCopyWithImpl(_$SplitError_EmptyImpl _value,
      $Res Function(_$SplitError_EmptyImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SplitError_EmptyImpl extends SplitError_Empty {
  const _$SplitError_EmptyImpl() : super._();

  @override
  String toString() {
    return 'SplitError.empty()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SplitError_EmptyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() cannotFit,
    required TResult Function(int field0) maxSplitSizeTooLarge,
    required TResult Function() minSplitTooSmall,
    required TResult Function() invalidSplitRange,
    required TResult Function() invalidVersionRange,
    required TResult Function(EncodeError field0) encodeError,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? cannotFit,
    TResult? Function(int field0)? maxSplitSizeTooLarge,
    TResult? Function()? minSplitTooSmall,
    TResult? Function()? invalidSplitRange,
    TResult? Function()? invalidVersionRange,
    TResult? Function(EncodeError field0)? encodeError,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? cannotFit,
    TResult Function(int field0)? maxSplitSizeTooLarge,
    TResult Function()? minSplitTooSmall,
    TResult Function()? invalidSplitRange,
    TResult Function()? invalidVersionRange,
    TResult Function(EncodeError field0)? encodeError,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SplitError_Empty value) empty,
    required TResult Function(SplitError_CannotFit value) cannotFit,
    required TResult Function(SplitError_MaxSplitSizeTooLarge value)
        maxSplitSizeTooLarge,
    required TResult Function(SplitError_MinSplitTooSmall value)
        minSplitTooSmall,
    required TResult Function(SplitError_InvalidSplitRange value)
        invalidSplitRange,
    required TResult Function(SplitError_InvalidVersionRange value)
        invalidVersionRange,
    required TResult Function(SplitError_EncodeError value) encodeError,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SplitError_Empty value)? empty,
    TResult? Function(SplitError_CannotFit value)? cannotFit,
    TResult? Function(SplitError_MaxSplitSizeTooLarge value)?
        maxSplitSizeTooLarge,
    TResult? Function(SplitError_MinSplitTooSmall value)? minSplitTooSmall,
    TResult? Function(SplitError_InvalidSplitRange value)? invalidSplitRange,
    TResult? Function(SplitError_InvalidVersionRange value)?
        invalidVersionRange,
    TResult? Function(SplitError_EncodeError value)? encodeError,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SplitError_Empty value)? empty,
    TResult Function(SplitError_CannotFit value)? cannotFit,
    TResult Function(SplitError_MaxSplitSizeTooLarge value)?
        maxSplitSizeTooLarge,
    TResult Function(SplitError_MinSplitTooSmall value)? minSplitTooSmall,
    TResult Function(SplitError_InvalidSplitRange value)? invalidSplitRange,
    TResult Function(SplitError_InvalidVersionRange value)? invalidVersionRange,
    TResult Function(SplitError_EncodeError value)? encodeError,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class SplitError_Empty extends SplitError {
  const factory SplitError_Empty() = _$SplitError_EmptyImpl;
  const SplitError_Empty._() : super._();
}

/// @nodoc
abstract class _$$SplitError_CannotFitImplCopyWith<$Res> {
  factory _$$SplitError_CannotFitImplCopyWith(_$SplitError_CannotFitImpl value,
          $Res Function(_$SplitError_CannotFitImpl) then) =
      __$$SplitError_CannotFitImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SplitError_CannotFitImplCopyWithImpl<$Res>
    extends _$SplitErrorCopyWithImpl<$Res, _$SplitError_CannotFitImpl>
    implements _$$SplitError_CannotFitImplCopyWith<$Res> {
  __$$SplitError_CannotFitImplCopyWithImpl(_$SplitError_CannotFitImpl _value,
      $Res Function(_$SplitError_CannotFitImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SplitError_CannotFitImpl extends SplitError_CannotFit {
  const _$SplitError_CannotFitImpl() : super._();

  @override
  String toString() {
    return 'SplitError.cannotFit()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SplitError_CannotFitImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() cannotFit,
    required TResult Function(int field0) maxSplitSizeTooLarge,
    required TResult Function() minSplitTooSmall,
    required TResult Function() invalidSplitRange,
    required TResult Function() invalidVersionRange,
    required TResult Function(EncodeError field0) encodeError,
  }) {
    return cannotFit();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? cannotFit,
    TResult? Function(int field0)? maxSplitSizeTooLarge,
    TResult? Function()? minSplitTooSmall,
    TResult? Function()? invalidSplitRange,
    TResult? Function()? invalidVersionRange,
    TResult? Function(EncodeError field0)? encodeError,
  }) {
    return cannotFit?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? cannotFit,
    TResult Function(int field0)? maxSplitSizeTooLarge,
    TResult Function()? minSplitTooSmall,
    TResult Function()? invalidSplitRange,
    TResult Function()? invalidVersionRange,
    TResult Function(EncodeError field0)? encodeError,
    required TResult orElse(),
  }) {
    if (cannotFit != null) {
      return cannotFit();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SplitError_Empty value) empty,
    required TResult Function(SplitError_CannotFit value) cannotFit,
    required TResult Function(SplitError_MaxSplitSizeTooLarge value)
        maxSplitSizeTooLarge,
    required TResult Function(SplitError_MinSplitTooSmall value)
        minSplitTooSmall,
    required TResult Function(SplitError_InvalidSplitRange value)
        invalidSplitRange,
    required TResult Function(SplitError_InvalidVersionRange value)
        invalidVersionRange,
    required TResult Function(SplitError_EncodeError value) encodeError,
  }) {
    return cannotFit(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SplitError_Empty value)? empty,
    TResult? Function(SplitError_CannotFit value)? cannotFit,
    TResult? Function(SplitError_MaxSplitSizeTooLarge value)?
        maxSplitSizeTooLarge,
    TResult? Function(SplitError_MinSplitTooSmall value)? minSplitTooSmall,
    TResult? Function(SplitError_InvalidSplitRange value)? invalidSplitRange,
    TResult? Function(SplitError_InvalidVersionRange value)?
        invalidVersionRange,
    TResult? Function(SplitError_EncodeError value)? encodeError,
  }) {
    return cannotFit?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SplitError_Empty value)? empty,
    TResult Function(SplitError_CannotFit value)? cannotFit,
    TResult Function(SplitError_MaxSplitSizeTooLarge value)?
        maxSplitSizeTooLarge,
    TResult Function(SplitError_MinSplitTooSmall value)? minSplitTooSmall,
    TResult Function(SplitError_InvalidSplitRange value)? invalidSplitRange,
    TResult Function(SplitError_InvalidVersionRange value)? invalidVersionRange,
    TResult Function(SplitError_EncodeError value)? encodeError,
    required TResult orElse(),
  }) {
    if (cannotFit != null) {
      return cannotFit(this);
    }
    return orElse();
  }
}

abstract class SplitError_CannotFit extends SplitError {
  const factory SplitError_CannotFit() = _$SplitError_CannotFitImpl;
  const SplitError_CannotFit._() : super._();
}

/// @nodoc
abstract class _$$SplitError_MaxSplitSizeTooLargeImplCopyWith<$Res> {
  factory _$$SplitError_MaxSplitSizeTooLargeImplCopyWith(
          _$SplitError_MaxSplitSizeTooLargeImpl value,
          $Res Function(_$SplitError_MaxSplitSizeTooLargeImpl) then) =
      __$$SplitError_MaxSplitSizeTooLargeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$SplitError_MaxSplitSizeTooLargeImplCopyWithImpl<$Res>
    extends _$SplitErrorCopyWithImpl<$Res,
        _$SplitError_MaxSplitSizeTooLargeImpl>
    implements _$$SplitError_MaxSplitSizeTooLargeImplCopyWith<$Res> {
  __$$SplitError_MaxSplitSizeTooLargeImplCopyWithImpl(
      _$SplitError_MaxSplitSizeTooLargeImpl _value,
      $Res Function(_$SplitError_MaxSplitSizeTooLargeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$SplitError_MaxSplitSizeTooLargeImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$SplitError_MaxSplitSizeTooLargeImpl
    extends SplitError_MaxSplitSizeTooLarge {
  const _$SplitError_MaxSplitSizeTooLargeImpl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'SplitError.maxSplitSizeTooLarge(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SplitError_MaxSplitSizeTooLargeImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SplitError_MaxSplitSizeTooLargeImplCopyWith<
          _$SplitError_MaxSplitSizeTooLargeImpl>
      get copyWith => __$$SplitError_MaxSplitSizeTooLargeImplCopyWithImpl<
          _$SplitError_MaxSplitSizeTooLargeImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() cannotFit,
    required TResult Function(int field0) maxSplitSizeTooLarge,
    required TResult Function() minSplitTooSmall,
    required TResult Function() invalidSplitRange,
    required TResult Function() invalidVersionRange,
    required TResult Function(EncodeError field0) encodeError,
  }) {
    return maxSplitSizeTooLarge(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? cannotFit,
    TResult? Function(int field0)? maxSplitSizeTooLarge,
    TResult? Function()? minSplitTooSmall,
    TResult? Function()? invalidSplitRange,
    TResult? Function()? invalidVersionRange,
    TResult? Function(EncodeError field0)? encodeError,
  }) {
    return maxSplitSizeTooLarge?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? cannotFit,
    TResult Function(int field0)? maxSplitSizeTooLarge,
    TResult Function()? minSplitTooSmall,
    TResult Function()? invalidSplitRange,
    TResult Function()? invalidVersionRange,
    TResult Function(EncodeError field0)? encodeError,
    required TResult orElse(),
  }) {
    if (maxSplitSizeTooLarge != null) {
      return maxSplitSizeTooLarge(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SplitError_Empty value) empty,
    required TResult Function(SplitError_CannotFit value) cannotFit,
    required TResult Function(SplitError_MaxSplitSizeTooLarge value)
        maxSplitSizeTooLarge,
    required TResult Function(SplitError_MinSplitTooSmall value)
        minSplitTooSmall,
    required TResult Function(SplitError_InvalidSplitRange value)
        invalidSplitRange,
    required TResult Function(SplitError_InvalidVersionRange value)
        invalidVersionRange,
    required TResult Function(SplitError_EncodeError value) encodeError,
  }) {
    return maxSplitSizeTooLarge(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SplitError_Empty value)? empty,
    TResult? Function(SplitError_CannotFit value)? cannotFit,
    TResult? Function(SplitError_MaxSplitSizeTooLarge value)?
        maxSplitSizeTooLarge,
    TResult? Function(SplitError_MinSplitTooSmall value)? minSplitTooSmall,
    TResult? Function(SplitError_InvalidSplitRange value)? invalidSplitRange,
    TResult? Function(SplitError_InvalidVersionRange value)?
        invalidVersionRange,
    TResult? Function(SplitError_EncodeError value)? encodeError,
  }) {
    return maxSplitSizeTooLarge?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SplitError_Empty value)? empty,
    TResult Function(SplitError_CannotFit value)? cannotFit,
    TResult Function(SplitError_MaxSplitSizeTooLarge value)?
        maxSplitSizeTooLarge,
    TResult Function(SplitError_MinSplitTooSmall value)? minSplitTooSmall,
    TResult Function(SplitError_InvalidSplitRange value)? invalidSplitRange,
    TResult Function(SplitError_InvalidVersionRange value)? invalidVersionRange,
    TResult Function(SplitError_EncodeError value)? encodeError,
    required TResult orElse(),
  }) {
    if (maxSplitSizeTooLarge != null) {
      return maxSplitSizeTooLarge(this);
    }
    return orElse();
  }
}

abstract class SplitError_MaxSplitSizeTooLarge extends SplitError {
  const factory SplitError_MaxSplitSizeTooLarge(final int field0) =
      _$SplitError_MaxSplitSizeTooLargeImpl;
  const SplitError_MaxSplitSizeTooLarge._() : super._();

  int get field0;
  @JsonKey(ignore: true)
  _$$SplitError_MaxSplitSizeTooLargeImplCopyWith<
          _$SplitError_MaxSplitSizeTooLargeImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SplitError_MinSplitTooSmallImplCopyWith<$Res> {
  factory _$$SplitError_MinSplitTooSmallImplCopyWith(
          _$SplitError_MinSplitTooSmallImpl value,
          $Res Function(_$SplitError_MinSplitTooSmallImpl) then) =
      __$$SplitError_MinSplitTooSmallImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SplitError_MinSplitTooSmallImplCopyWithImpl<$Res>
    extends _$SplitErrorCopyWithImpl<$Res, _$SplitError_MinSplitTooSmallImpl>
    implements _$$SplitError_MinSplitTooSmallImplCopyWith<$Res> {
  __$$SplitError_MinSplitTooSmallImplCopyWithImpl(
      _$SplitError_MinSplitTooSmallImpl _value,
      $Res Function(_$SplitError_MinSplitTooSmallImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SplitError_MinSplitTooSmallImpl extends SplitError_MinSplitTooSmall {
  const _$SplitError_MinSplitTooSmallImpl() : super._();

  @override
  String toString() {
    return 'SplitError.minSplitTooSmall()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SplitError_MinSplitTooSmallImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() cannotFit,
    required TResult Function(int field0) maxSplitSizeTooLarge,
    required TResult Function() minSplitTooSmall,
    required TResult Function() invalidSplitRange,
    required TResult Function() invalidVersionRange,
    required TResult Function(EncodeError field0) encodeError,
  }) {
    return minSplitTooSmall();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? cannotFit,
    TResult? Function(int field0)? maxSplitSizeTooLarge,
    TResult? Function()? minSplitTooSmall,
    TResult? Function()? invalidSplitRange,
    TResult? Function()? invalidVersionRange,
    TResult? Function(EncodeError field0)? encodeError,
  }) {
    return minSplitTooSmall?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? cannotFit,
    TResult Function(int field0)? maxSplitSizeTooLarge,
    TResult Function()? minSplitTooSmall,
    TResult Function()? invalidSplitRange,
    TResult Function()? invalidVersionRange,
    TResult Function(EncodeError field0)? encodeError,
    required TResult orElse(),
  }) {
    if (minSplitTooSmall != null) {
      return minSplitTooSmall();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SplitError_Empty value) empty,
    required TResult Function(SplitError_CannotFit value) cannotFit,
    required TResult Function(SplitError_MaxSplitSizeTooLarge value)
        maxSplitSizeTooLarge,
    required TResult Function(SplitError_MinSplitTooSmall value)
        minSplitTooSmall,
    required TResult Function(SplitError_InvalidSplitRange value)
        invalidSplitRange,
    required TResult Function(SplitError_InvalidVersionRange value)
        invalidVersionRange,
    required TResult Function(SplitError_EncodeError value) encodeError,
  }) {
    return minSplitTooSmall(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SplitError_Empty value)? empty,
    TResult? Function(SplitError_CannotFit value)? cannotFit,
    TResult? Function(SplitError_MaxSplitSizeTooLarge value)?
        maxSplitSizeTooLarge,
    TResult? Function(SplitError_MinSplitTooSmall value)? minSplitTooSmall,
    TResult? Function(SplitError_InvalidSplitRange value)? invalidSplitRange,
    TResult? Function(SplitError_InvalidVersionRange value)?
        invalidVersionRange,
    TResult? Function(SplitError_EncodeError value)? encodeError,
  }) {
    return minSplitTooSmall?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SplitError_Empty value)? empty,
    TResult Function(SplitError_CannotFit value)? cannotFit,
    TResult Function(SplitError_MaxSplitSizeTooLarge value)?
        maxSplitSizeTooLarge,
    TResult Function(SplitError_MinSplitTooSmall value)? minSplitTooSmall,
    TResult Function(SplitError_InvalidSplitRange value)? invalidSplitRange,
    TResult Function(SplitError_InvalidVersionRange value)? invalidVersionRange,
    TResult Function(SplitError_EncodeError value)? encodeError,
    required TResult orElse(),
  }) {
    if (minSplitTooSmall != null) {
      return minSplitTooSmall(this);
    }
    return orElse();
  }
}

abstract class SplitError_MinSplitTooSmall extends SplitError {
  const factory SplitError_MinSplitTooSmall() =
      _$SplitError_MinSplitTooSmallImpl;
  const SplitError_MinSplitTooSmall._() : super._();
}

/// @nodoc
abstract class _$$SplitError_InvalidSplitRangeImplCopyWith<$Res> {
  factory _$$SplitError_InvalidSplitRangeImplCopyWith(
          _$SplitError_InvalidSplitRangeImpl value,
          $Res Function(_$SplitError_InvalidSplitRangeImpl) then) =
      __$$SplitError_InvalidSplitRangeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SplitError_InvalidSplitRangeImplCopyWithImpl<$Res>
    extends _$SplitErrorCopyWithImpl<$Res, _$SplitError_InvalidSplitRangeImpl>
    implements _$$SplitError_InvalidSplitRangeImplCopyWith<$Res> {
  __$$SplitError_InvalidSplitRangeImplCopyWithImpl(
      _$SplitError_InvalidSplitRangeImpl _value,
      $Res Function(_$SplitError_InvalidSplitRangeImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SplitError_InvalidSplitRangeImpl extends SplitError_InvalidSplitRange {
  const _$SplitError_InvalidSplitRangeImpl() : super._();

  @override
  String toString() {
    return 'SplitError.invalidSplitRange()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SplitError_InvalidSplitRangeImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() cannotFit,
    required TResult Function(int field0) maxSplitSizeTooLarge,
    required TResult Function() minSplitTooSmall,
    required TResult Function() invalidSplitRange,
    required TResult Function() invalidVersionRange,
    required TResult Function(EncodeError field0) encodeError,
  }) {
    return invalidSplitRange();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? cannotFit,
    TResult? Function(int field0)? maxSplitSizeTooLarge,
    TResult? Function()? minSplitTooSmall,
    TResult? Function()? invalidSplitRange,
    TResult? Function()? invalidVersionRange,
    TResult? Function(EncodeError field0)? encodeError,
  }) {
    return invalidSplitRange?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? cannotFit,
    TResult Function(int field0)? maxSplitSizeTooLarge,
    TResult Function()? minSplitTooSmall,
    TResult Function()? invalidSplitRange,
    TResult Function()? invalidVersionRange,
    TResult Function(EncodeError field0)? encodeError,
    required TResult orElse(),
  }) {
    if (invalidSplitRange != null) {
      return invalidSplitRange();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SplitError_Empty value) empty,
    required TResult Function(SplitError_CannotFit value) cannotFit,
    required TResult Function(SplitError_MaxSplitSizeTooLarge value)
        maxSplitSizeTooLarge,
    required TResult Function(SplitError_MinSplitTooSmall value)
        minSplitTooSmall,
    required TResult Function(SplitError_InvalidSplitRange value)
        invalidSplitRange,
    required TResult Function(SplitError_InvalidVersionRange value)
        invalidVersionRange,
    required TResult Function(SplitError_EncodeError value) encodeError,
  }) {
    return invalidSplitRange(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SplitError_Empty value)? empty,
    TResult? Function(SplitError_CannotFit value)? cannotFit,
    TResult? Function(SplitError_MaxSplitSizeTooLarge value)?
        maxSplitSizeTooLarge,
    TResult? Function(SplitError_MinSplitTooSmall value)? minSplitTooSmall,
    TResult? Function(SplitError_InvalidSplitRange value)? invalidSplitRange,
    TResult? Function(SplitError_InvalidVersionRange value)?
        invalidVersionRange,
    TResult? Function(SplitError_EncodeError value)? encodeError,
  }) {
    return invalidSplitRange?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SplitError_Empty value)? empty,
    TResult Function(SplitError_CannotFit value)? cannotFit,
    TResult Function(SplitError_MaxSplitSizeTooLarge value)?
        maxSplitSizeTooLarge,
    TResult Function(SplitError_MinSplitTooSmall value)? minSplitTooSmall,
    TResult Function(SplitError_InvalidSplitRange value)? invalidSplitRange,
    TResult Function(SplitError_InvalidVersionRange value)? invalidVersionRange,
    TResult Function(SplitError_EncodeError value)? encodeError,
    required TResult orElse(),
  }) {
    if (invalidSplitRange != null) {
      return invalidSplitRange(this);
    }
    return orElse();
  }
}

abstract class SplitError_InvalidSplitRange extends SplitError {
  const factory SplitError_InvalidSplitRange() =
      _$SplitError_InvalidSplitRangeImpl;
  const SplitError_InvalidSplitRange._() : super._();
}

/// @nodoc
abstract class _$$SplitError_InvalidVersionRangeImplCopyWith<$Res> {
  factory _$$SplitError_InvalidVersionRangeImplCopyWith(
          _$SplitError_InvalidVersionRangeImpl value,
          $Res Function(_$SplitError_InvalidVersionRangeImpl) then) =
      __$$SplitError_InvalidVersionRangeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SplitError_InvalidVersionRangeImplCopyWithImpl<$Res>
    extends _$SplitErrorCopyWithImpl<$Res, _$SplitError_InvalidVersionRangeImpl>
    implements _$$SplitError_InvalidVersionRangeImplCopyWith<$Res> {
  __$$SplitError_InvalidVersionRangeImplCopyWithImpl(
      _$SplitError_InvalidVersionRangeImpl _value,
      $Res Function(_$SplitError_InvalidVersionRangeImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SplitError_InvalidVersionRangeImpl
    extends SplitError_InvalidVersionRange {
  const _$SplitError_InvalidVersionRangeImpl() : super._();

  @override
  String toString() {
    return 'SplitError.invalidVersionRange()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SplitError_InvalidVersionRangeImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() cannotFit,
    required TResult Function(int field0) maxSplitSizeTooLarge,
    required TResult Function() minSplitTooSmall,
    required TResult Function() invalidSplitRange,
    required TResult Function() invalidVersionRange,
    required TResult Function(EncodeError field0) encodeError,
  }) {
    return invalidVersionRange();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? cannotFit,
    TResult? Function(int field0)? maxSplitSizeTooLarge,
    TResult? Function()? minSplitTooSmall,
    TResult? Function()? invalidSplitRange,
    TResult? Function()? invalidVersionRange,
    TResult? Function(EncodeError field0)? encodeError,
  }) {
    return invalidVersionRange?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? cannotFit,
    TResult Function(int field0)? maxSplitSizeTooLarge,
    TResult Function()? minSplitTooSmall,
    TResult Function()? invalidSplitRange,
    TResult Function()? invalidVersionRange,
    TResult Function(EncodeError field0)? encodeError,
    required TResult orElse(),
  }) {
    if (invalidVersionRange != null) {
      return invalidVersionRange();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SplitError_Empty value) empty,
    required TResult Function(SplitError_CannotFit value) cannotFit,
    required TResult Function(SplitError_MaxSplitSizeTooLarge value)
        maxSplitSizeTooLarge,
    required TResult Function(SplitError_MinSplitTooSmall value)
        minSplitTooSmall,
    required TResult Function(SplitError_InvalidSplitRange value)
        invalidSplitRange,
    required TResult Function(SplitError_InvalidVersionRange value)
        invalidVersionRange,
    required TResult Function(SplitError_EncodeError value) encodeError,
  }) {
    return invalidVersionRange(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SplitError_Empty value)? empty,
    TResult? Function(SplitError_CannotFit value)? cannotFit,
    TResult? Function(SplitError_MaxSplitSizeTooLarge value)?
        maxSplitSizeTooLarge,
    TResult? Function(SplitError_MinSplitTooSmall value)? minSplitTooSmall,
    TResult? Function(SplitError_InvalidSplitRange value)? invalidSplitRange,
    TResult? Function(SplitError_InvalidVersionRange value)?
        invalidVersionRange,
    TResult? Function(SplitError_EncodeError value)? encodeError,
  }) {
    return invalidVersionRange?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SplitError_Empty value)? empty,
    TResult Function(SplitError_CannotFit value)? cannotFit,
    TResult Function(SplitError_MaxSplitSizeTooLarge value)?
        maxSplitSizeTooLarge,
    TResult Function(SplitError_MinSplitTooSmall value)? minSplitTooSmall,
    TResult Function(SplitError_InvalidSplitRange value)? invalidSplitRange,
    TResult Function(SplitError_InvalidVersionRange value)? invalidVersionRange,
    TResult Function(SplitError_EncodeError value)? encodeError,
    required TResult orElse(),
  }) {
    if (invalidVersionRange != null) {
      return invalidVersionRange(this);
    }
    return orElse();
  }
}

abstract class SplitError_InvalidVersionRange extends SplitError {
  const factory SplitError_InvalidVersionRange() =
      _$SplitError_InvalidVersionRangeImpl;
  const SplitError_InvalidVersionRange._() : super._();
}

/// @nodoc
abstract class _$$SplitError_EncodeErrorImplCopyWith<$Res> {
  factory _$$SplitError_EncodeErrorImplCopyWith(
          _$SplitError_EncodeErrorImpl value,
          $Res Function(_$SplitError_EncodeErrorImpl) then) =
      __$$SplitError_EncodeErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({EncodeError field0});

  $EncodeErrorCopyWith<$Res> get field0;
}

/// @nodoc
class __$$SplitError_EncodeErrorImplCopyWithImpl<$Res>
    extends _$SplitErrorCopyWithImpl<$Res, _$SplitError_EncodeErrorImpl>
    implements _$$SplitError_EncodeErrorImplCopyWith<$Res> {
  __$$SplitError_EncodeErrorImplCopyWithImpl(
      _$SplitError_EncodeErrorImpl _value,
      $Res Function(_$SplitError_EncodeErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$SplitError_EncodeErrorImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as EncodeError,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $EncodeErrorCopyWith<$Res> get field0 {
    return $EncodeErrorCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$SplitError_EncodeErrorImpl extends SplitError_EncodeError {
  const _$SplitError_EncodeErrorImpl(this.field0) : super._();

  @override
  final EncodeError field0;

  @override
  String toString() {
    return 'SplitError.encodeError(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SplitError_EncodeErrorImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SplitError_EncodeErrorImplCopyWith<_$SplitError_EncodeErrorImpl>
      get copyWith => __$$SplitError_EncodeErrorImplCopyWithImpl<
          _$SplitError_EncodeErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() cannotFit,
    required TResult Function(int field0) maxSplitSizeTooLarge,
    required TResult Function() minSplitTooSmall,
    required TResult Function() invalidSplitRange,
    required TResult Function() invalidVersionRange,
    required TResult Function(EncodeError field0) encodeError,
  }) {
    return encodeError(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? cannotFit,
    TResult? Function(int field0)? maxSplitSizeTooLarge,
    TResult? Function()? minSplitTooSmall,
    TResult? Function()? invalidSplitRange,
    TResult? Function()? invalidVersionRange,
    TResult? Function(EncodeError field0)? encodeError,
  }) {
    return encodeError?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? cannotFit,
    TResult Function(int field0)? maxSplitSizeTooLarge,
    TResult Function()? minSplitTooSmall,
    TResult Function()? invalidSplitRange,
    TResult Function()? invalidVersionRange,
    TResult Function(EncodeError field0)? encodeError,
    required TResult orElse(),
  }) {
    if (encodeError != null) {
      return encodeError(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SplitError_Empty value) empty,
    required TResult Function(SplitError_CannotFit value) cannotFit,
    required TResult Function(SplitError_MaxSplitSizeTooLarge value)
        maxSplitSizeTooLarge,
    required TResult Function(SplitError_MinSplitTooSmall value)
        minSplitTooSmall,
    required TResult Function(SplitError_InvalidSplitRange value)
        invalidSplitRange,
    required TResult Function(SplitError_InvalidVersionRange value)
        invalidVersionRange,
    required TResult Function(SplitError_EncodeError value) encodeError,
  }) {
    return encodeError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SplitError_Empty value)? empty,
    TResult? Function(SplitError_CannotFit value)? cannotFit,
    TResult? Function(SplitError_MaxSplitSizeTooLarge value)?
        maxSplitSizeTooLarge,
    TResult? Function(SplitError_MinSplitTooSmall value)? minSplitTooSmall,
    TResult? Function(SplitError_InvalidSplitRange value)? invalidSplitRange,
    TResult? Function(SplitError_InvalidVersionRange value)?
        invalidVersionRange,
    TResult? Function(SplitError_EncodeError value)? encodeError,
  }) {
    return encodeError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SplitError_Empty value)? empty,
    TResult Function(SplitError_CannotFit value)? cannotFit,
    TResult Function(SplitError_MaxSplitSizeTooLarge value)?
        maxSplitSizeTooLarge,
    TResult Function(SplitError_MinSplitTooSmall value)? minSplitTooSmall,
    TResult Function(SplitError_InvalidSplitRange value)? invalidSplitRange,
    TResult Function(SplitError_InvalidVersionRange value)? invalidVersionRange,
    TResult Function(SplitError_EncodeError value)? encodeError,
    required TResult orElse(),
  }) {
    if (encodeError != null) {
      return encodeError(this);
    }
    return orElse();
  }
}

abstract class SplitError_EncodeError extends SplitError {
  const factory SplitError_EncodeError(final EncodeError field0) =
      _$SplitError_EncodeErrorImpl;
  const SplitError_EncodeError._() : super._();

  EncodeError get field0;
  @JsonKey(ignore: true)
  _$$SplitError_EncodeErrorImplCopyWith<_$SplitError_EncodeErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}
