// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'error.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$DecodeError {
  Object get field0 => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0, String field1) unableToDecodeHex,
    required TResult Function(int field0, String field1) unableToDecodeBase32,
    required TResult Function(String field0) unableToInflateZlib,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0, String field1)? unableToDecodeHex,
    TResult? Function(int field0, String field1)? unableToDecodeBase32,
    TResult? Function(String field0)? unableToInflateZlib,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0, String field1)? unableToDecodeHex,
    TResult Function(int field0, String field1)? unableToDecodeBase32,
    TResult Function(String field0)? unableToInflateZlib,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DecodeError_UnableToDecodeHex value)
        unableToDecodeHex,
    required TResult Function(DecodeError_UnableToDecodeBase32 value)
        unableToDecodeBase32,
    required TResult Function(DecodeError_UnableToInflateZlib value)
        unableToInflateZlib,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DecodeError_UnableToDecodeHex value)? unableToDecodeHex,
    TResult? Function(DecodeError_UnableToDecodeBase32 value)?
        unableToDecodeBase32,
    TResult? Function(DecodeError_UnableToInflateZlib value)?
        unableToInflateZlib,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DecodeError_UnableToDecodeHex value)? unableToDecodeHex,
    TResult Function(DecodeError_UnableToDecodeBase32 value)?
        unableToDecodeBase32,
    TResult Function(DecodeError_UnableToInflateZlib value)?
        unableToInflateZlib,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DecodeErrorCopyWith<$Res> {
  factory $DecodeErrorCopyWith(
          DecodeError value, $Res Function(DecodeError) then) =
      _$DecodeErrorCopyWithImpl<$Res, DecodeError>;
}

/// @nodoc
class _$DecodeErrorCopyWithImpl<$Res, $Val extends DecodeError>
    implements $DecodeErrorCopyWith<$Res> {
  _$DecodeErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$DecodeError_UnableToDecodeHexImplCopyWith<$Res> {
  factory _$$DecodeError_UnableToDecodeHexImplCopyWith(
          _$DecodeError_UnableToDecodeHexImpl value,
          $Res Function(_$DecodeError_UnableToDecodeHexImpl) then) =
      __$$DecodeError_UnableToDecodeHexImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0, String field1});
}

/// @nodoc
class __$$DecodeError_UnableToDecodeHexImplCopyWithImpl<$Res>
    extends _$DecodeErrorCopyWithImpl<$Res, _$DecodeError_UnableToDecodeHexImpl>
    implements _$$DecodeError_UnableToDecodeHexImplCopyWith<$Res> {
  __$$DecodeError_UnableToDecodeHexImplCopyWithImpl(
      _$DecodeError_UnableToDecodeHexImpl _value,
      $Res Function(_$DecodeError_UnableToDecodeHexImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
    Object? field1 = null,
  }) {
    return _then(_$DecodeError_UnableToDecodeHexImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
      null == field1
          ? _value.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$DecodeError_UnableToDecodeHexImpl
    extends DecodeError_UnableToDecodeHex {
  const _$DecodeError_UnableToDecodeHexImpl(this.field0, this.field1)
      : super._();

  @override
  final int field0;
  @override
  final String field1;

  @override
  String toString() {
    return 'DecodeError.unableToDecodeHex(field0: $field0, field1: $field1)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DecodeError_UnableToDecodeHexImpl &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0, field1);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DecodeError_UnableToDecodeHexImplCopyWith<
          _$DecodeError_UnableToDecodeHexImpl>
      get copyWith => __$$DecodeError_UnableToDecodeHexImplCopyWithImpl<
          _$DecodeError_UnableToDecodeHexImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0, String field1) unableToDecodeHex,
    required TResult Function(int field0, String field1) unableToDecodeBase32,
    required TResult Function(String field0) unableToInflateZlib,
  }) {
    return unableToDecodeHex(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0, String field1)? unableToDecodeHex,
    TResult? Function(int field0, String field1)? unableToDecodeBase32,
    TResult? Function(String field0)? unableToInflateZlib,
  }) {
    return unableToDecodeHex?.call(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0, String field1)? unableToDecodeHex,
    TResult Function(int field0, String field1)? unableToDecodeBase32,
    TResult Function(String field0)? unableToInflateZlib,
    required TResult orElse(),
  }) {
    if (unableToDecodeHex != null) {
      return unableToDecodeHex(field0, field1);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DecodeError_UnableToDecodeHex value)
        unableToDecodeHex,
    required TResult Function(DecodeError_UnableToDecodeBase32 value)
        unableToDecodeBase32,
    required TResult Function(DecodeError_UnableToInflateZlib value)
        unableToInflateZlib,
  }) {
    return unableToDecodeHex(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DecodeError_UnableToDecodeHex value)? unableToDecodeHex,
    TResult? Function(DecodeError_UnableToDecodeBase32 value)?
        unableToDecodeBase32,
    TResult? Function(DecodeError_UnableToInflateZlib value)?
        unableToInflateZlib,
  }) {
    return unableToDecodeHex?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DecodeError_UnableToDecodeHex value)? unableToDecodeHex,
    TResult Function(DecodeError_UnableToDecodeBase32 value)?
        unableToDecodeBase32,
    TResult Function(DecodeError_UnableToInflateZlib value)?
        unableToInflateZlib,
    required TResult orElse(),
  }) {
    if (unableToDecodeHex != null) {
      return unableToDecodeHex(this);
    }
    return orElse();
  }
}

abstract class DecodeError_UnableToDecodeHex extends DecodeError {
  const factory DecodeError_UnableToDecodeHex(
          final int field0, final String field1) =
      _$DecodeError_UnableToDecodeHexImpl;
  const DecodeError_UnableToDecodeHex._() : super._();

  @override
  int get field0;
  String get field1;
  @JsonKey(ignore: true)
  _$$DecodeError_UnableToDecodeHexImplCopyWith<
          _$DecodeError_UnableToDecodeHexImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DecodeError_UnableToDecodeBase32ImplCopyWith<$Res> {
  factory _$$DecodeError_UnableToDecodeBase32ImplCopyWith(
          _$DecodeError_UnableToDecodeBase32Impl value,
          $Res Function(_$DecodeError_UnableToDecodeBase32Impl) then) =
      __$$DecodeError_UnableToDecodeBase32ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0, String field1});
}

/// @nodoc
class __$$DecodeError_UnableToDecodeBase32ImplCopyWithImpl<$Res>
    extends _$DecodeErrorCopyWithImpl<$Res,
        _$DecodeError_UnableToDecodeBase32Impl>
    implements _$$DecodeError_UnableToDecodeBase32ImplCopyWith<$Res> {
  __$$DecodeError_UnableToDecodeBase32ImplCopyWithImpl(
      _$DecodeError_UnableToDecodeBase32Impl _value,
      $Res Function(_$DecodeError_UnableToDecodeBase32Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
    Object? field1 = null,
  }) {
    return _then(_$DecodeError_UnableToDecodeBase32Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
      null == field1
          ? _value.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$DecodeError_UnableToDecodeBase32Impl
    extends DecodeError_UnableToDecodeBase32 {
  const _$DecodeError_UnableToDecodeBase32Impl(this.field0, this.field1)
      : super._();

  @override
  final int field0;
  @override
  final String field1;

  @override
  String toString() {
    return 'DecodeError.unableToDecodeBase32(field0: $field0, field1: $field1)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DecodeError_UnableToDecodeBase32Impl &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0, field1);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DecodeError_UnableToDecodeBase32ImplCopyWith<
          _$DecodeError_UnableToDecodeBase32Impl>
      get copyWith => __$$DecodeError_UnableToDecodeBase32ImplCopyWithImpl<
          _$DecodeError_UnableToDecodeBase32Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0, String field1) unableToDecodeHex,
    required TResult Function(int field0, String field1) unableToDecodeBase32,
    required TResult Function(String field0) unableToInflateZlib,
  }) {
    return unableToDecodeBase32(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0, String field1)? unableToDecodeHex,
    TResult? Function(int field0, String field1)? unableToDecodeBase32,
    TResult? Function(String field0)? unableToInflateZlib,
  }) {
    return unableToDecodeBase32?.call(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0, String field1)? unableToDecodeHex,
    TResult Function(int field0, String field1)? unableToDecodeBase32,
    TResult Function(String field0)? unableToInflateZlib,
    required TResult orElse(),
  }) {
    if (unableToDecodeBase32 != null) {
      return unableToDecodeBase32(field0, field1);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DecodeError_UnableToDecodeHex value)
        unableToDecodeHex,
    required TResult Function(DecodeError_UnableToDecodeBase32 value)
        unableToDecodeBase32,
    required TResult Function(DecodeError_UnableToInflateZlib value)
        unableToInflateZlib,
  }) {
    return unableToDecodeBase32(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DecodeError_UnableToDecodeHex value)? unableToDecodeHex,
    TResult? Function(DecodeError_UnableToDecodeBase32 value)?
        unableToDecodeBase32,
    TResult? Function(DecodeError_UnableToInflateZlib value)?
        unableToInflateZlib,
  }) {
    return unableToDecodeBase32?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DecodeError_UnableToDecodeHex value)? unableToDecodeHex,
    TResult Function(DecodeError_UnableToDecodeBase32 value)?
        unableToDecodeBase32,
    TResult Function(DecodeError_UnableToInflateZlib value)?
        unableToInflateZlib,
    required TResult orElse(),
  }) {
    if (unableToDecodeBase32 != null) {
      return unableToDecodeBase32(this);
    }
    return orElse();
  }
}

abstract class DecodeError_UnableToDecodeBase32 extends DecodeError {
  const factory DecodeError_UnableToDecodeBase32(
          final int field0, final String field1) =
      _$DecodeError_UnableToDecodeBase32Impl;
  const DecodeError_UnableToDecodeBase32._() : super._();

  @override
  int get field0;
  String get field1;
  @JsonKey(ignore: true)
  _$$DecodeError_UnableToDecodeBase32ImplCopyWith<
          _$DecodeError_UnableToDecodeBase32Impl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DecodeError_UnableToInflateZlibImplCopyWith<$Res> {
  factory _$$DecodeError_UnableToInflateZlibImplCopyWith(
          _$DecodeError_UnableToInflateZlibImpl value,
          $Res Function(_$DecodeError_UnableToInflateZlibImpl) then) =
      __$$DecodeError_UnableToInflateZlibImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$DecodeError_UnableToInflateZlibImplCopyWithImpl<$Res>
    extends _$DecodeErrorCopyWithImpl<$Res,
        _$DecodeError_UnableToInflateZlibImpl>
    implements _$$DecodeError_UnableToInflateZlibImplCopyWith<$Res> {
  __$$DecodeError_UnableToInflateZlibImplCopyWithImpl(
      _$DecodeError_UnableToInflateZlibImpl _value,
      $Res Function(_$DecodeError_UnableToInflateZlibImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$DecodeError_UnableToInflateZlibImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$DecodeError_UnableToInflateZlibImpl
    extends DecodeError_UnableToInflateZlib {
  const _$DecodeError_UnableToInflateZlibImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'DecodeError.unableToInflateZlib(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DecodeError_UnableToInflateZlibImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DecodeError_UnableToInflateZlibImplCopyWith<
          _$DecodeError_UnableToInflateZlibImpl>
      get copyWith => __$$DecodeError_UnableToInflateZlibImplCopyWithImpl<
          _$DecodeError_UnableToInflateZlibImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0, String field1) unableToDecodeHex,
    required TResult Function(int field0, String field1) unableToDecodeBase32,
    required TResult Function(String field0) unableToInflateZlib,
  }) {
    return unableToInflateZlib(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0, String field1)? unableToDecodeHex,
    TResult? Function(int field0, String field1)? unableToDecodeBase32,
    TResult? Function(String field0)? unableToInflateZlib,
  }) {
    return unableToInflateZlib?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0, String field1)? unableToDecodeHex,
    TResult Function(int field0, String field1)? unableToDecodeBase32,
    TResult Function(String field0)? unableToInflateZlib,
    required TResult orElse(),
  }) {
    if (unableToInflateZlib != null) {
      return unableToInflateZlib(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DecodeError_UnableToDecodeHex value)
        unableToDecodeHex,
    required TResult Function(DecodeError_UnableToDecodeBase32 value)
        unableToDecodeBase32,
    required TResult Function(DecodeError_UnableToInflateZlib value)
        unableToInflateZlib,
  }) {
    return unableToInflateZlib(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DecodeError_UnableToDecodeHex value)? unableToDecodeHex,
    TResult? Function(DecodeError_UnableToDecodeBase32 value)?
        unableToDecodeBase32,
    TResult? Function(DecodeError_UnableToInflateZlib value)?
        unableToInflateZlib,
  }) {
    return unableToInflateZlib?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DecodeError_UnableToDecodeHex value)? unableToDecodeHex,
    TResult Function(DecodeError_UnableToDecodeBase32 value)?
        unableToDecodeBase32,
    TResult Function(DecodeError_UnableToInflateZlib value)?
        unableToInflateZlib,
    required TResult orElse(),
  }) {
    if (unableToInflateZlib != null) {
      return unableToInflateZlib(this);
    }
    return orElse();
  }
}

abstract class DecodeError_UnableToInflateZlib extends DecodeError {
  const factory DecodeError_UnableToInflateZlib(final String field0) =
      _$DecodeError_UnableToInflateZlibImpl;
  const DecodeError_UnableToInflateZlib._() : super._();

  @override
  String get field0;
  @JsonKey(ignore: true)
  _$$DecodeError_UnableToInflateZlibImplCopyWith<
          _$DecodeError_UnableToInflateZlibImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$EncodeError {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(String field0) compressionError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(String field0)? compressionError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String field0)? compressionError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EncodeError_Empty value) empty,
    required TResult Function(EncodeError_CompressionError value)
        compressionError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EncodeError_Empty value)? empty,
    TResult? Function(EncodeError_CompressionError value)? compressionError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EncodeError_Empty value)? empty,
    TResult Function(EncodeError_CompressionError value)? compressionError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EncodeErrorCopyWith<$Res> {
  factory $EncodeErrorCopyWith(
          EncodeError value, $Res Function(EncodeError) then) =
      _$EncodeErrorCopyWithImpl<$Res, EncodeError>;
}

/// @nodoc
class _$EncodeErrorCopyWithImpl<$Res, $Val extends EncodeError>
    implements $EncodeErrorCopyWith<$Res> {
  _$EncodeErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$EncodeError_EmptyImplCopyWith<$Res> {
  factory _$$EncodeError_EmptyImplCopyWith(_$EncodeError_EmptyImpl value,
          $Res Function(_$EncodeError_EmptyImpl) then) =
      __$$EncodeError_EmptyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EncodeError_EmptyImplCopyWithImpl<$Res>
    extends _$EncodeErrorCopyWithImpl<$Res, _$EncodeError_EmptyImpl>
    implements _$$EncodeError_EmptyImplCopyWith<$Res> {
  __$$EncodeError_EmptyImplCopyWithImpl(_$EncodeError_EmptyImpl _value,
      $Res Function(_$EncodeError_EmptyImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$EncodeError_EmptyImpl extends EncodeError_Empty {
  const _$EncodeError_EmptyImpl() : super._();

  @override
  String toString() {
    return 'EncodeError.empty()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$EncodeError_EmptyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(String field0) compressionError,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(String field0)? compressionError,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String field0)? compressionError,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EncodeError_Empty value) empty,
    required TResult Function(EncodeError_CompressionError value)
        compressionError,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EncodeError_Empty value)? empty,
    TResult? Function(EncodeError_CompressionError value)? compressionError,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EncodeError_Empty value)? empty,
    TResult Function(EncodeError_CompressionError value)? compressionError,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class EncodeError_Empty extends EncodeError {
  const factory EncodeError_Empty() = _$EncodeError_EmptyImpl;
  const EncodeError_Empty._() : super._();
}

/// @nodoc
abstract class _$$EncodeError_CompressionErrorImplCopyWith<$Res> {
  factory _$$EncodeError_CompressionErrorImplCopyWith(
          _$EncodeError_CompressionErrorImpl value,
          $Res Function(_$EncodeError_CompressionErrorImpl) then) =
      __$$EncodeError_CompressionErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$EncodeError_CompressionErrorImplCopyWithImpl<$Res>
    extends _$EncodeErrorCopyWithImpl<$Res, _$EncodeError_CompressionErrorImpl>
    implements _$$EncodeError_CompressionErrorImplCopyWith<$Res> {
  __$$EncodeError_CompressionErrorImplCopyWithImpl(
      _$EncodeError_CompressionErrorImpl _value,
      $Res Function(_$EncodeError_CompressionErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$EncodeError_CompressionErrorImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$EncodeError_CompressionErrorImpl extends EncodeError_CompressionError {
  const _$EncodeError_CompressionErrorImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'EncodeError.compressionError(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EncodeError_CompressionErrorImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EncodeError_CompressionErrorImplCopyWith<
          _$EncodeError_CompressionErrorImpl>
      get copyWith => __$$EncodeError_CompressionErrorImplCopyWithImpl<
          _$EncodeError_CompressionErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(String field0) compressionError,
  }) {
    return compressionError(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(String field0)? compressionError,
  }) {
    return compressionError?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String field0)? compressionError,
    required TResult orElse(),
  }) {
    if (compressionError != null) {
      return compressionError(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EncodeError_Empty value) empty,
    required TResult Function(EncodeError_CompressionError value)
        compressionError,
  }) {
    return compressionError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EncodeError_Empty value)? empty,
    TResult? Function(EncodeError_CompressionError value)? compressionError,
  }) {
    return compressionError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EncodeError_Empty value)? empty,
    TResult Function(EncodeError_CompressionError value)? compressionError,
    required TResult orElse(),
  }) {
    if (compressionError != null) {
      return compressionError(this);
    }
    return orElse();
  }
}

abstract class EncodeError_CompressionError extends EncodeError {
  const factory EncodeError_CompressionError(final String field0) =
      _$EncodeError_CompressionErrorImpl;
  const EncodeError_CompressionError._() : super._();

  String get field0;
  @JsonKey(ignore: true)
  _$$EncodeError_CompressionErrorImplCopyWith<
          _$EncodeError_CompressionErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$HeaderParseError {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(String field0) invalidEncoding,
    required TResult Function(String field0) invalidFileType,
    required TResult Function() invalidFixedHeader,
    required TResult Function(int field0) invalidHeaderSize,
    required TResult Function(String field0) invalidHeaderParts,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(String field0)? invalidEncoding,
    TResult? Function(String field0)? invalidFileType,
    TResult? Function()? invalidFixedHeader,
    TResult? Function(int field0)? invalidHeaderSize,
    TResult? Function(String field0)? invalidHeaderParts,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String field0)? invalidEncoding,
    TResult Function(String field0)? invalidFileType,
    TResult Function()? invalidFixedHeader,
    TResult Function(int field0)? invalidHeaderSize,
    TResult Function(String field0)? invalidHeaderParts,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HeaderParseError_Empty value) empty,
    required TResult Function(HeaderParseError_InvalidEncoding value)
        invalidEncoding,
    required TResult Function(HeaderParseError_InvalidFileType value)
        invalidFileType,
    required TResult Function(HeaderParseError_InvalidFixedHeader value)
        invalidFixedHeader,
    required TResult Function(HeaderParseError_InvalidHeaderSize value)
        invalidHeaderSize,
    required TResult Function(HeaderParseError_InvalidHeaderParts value)
        invalidHeaderParts,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(HeaderParseError_Empty value)? empty,
    TResult? Function(HeaderParseError_InvalidEncoding value)? invalidEncoding,
    TResult? Function(HeaderParseError_InvalidFileType value)? invalidFileType,
    TResult? Function(HeaderParseError_InvalidFixedHeader value)?
        invalidFixedHeader,
    TResult? Function(HeaderParseError_InvalidHeaderSize value)?
        invalidHeaderSize,
    TResult? Function(HeaderParseError_InvalidHeaderParts value)?
        invalidHeaderParts,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HeaderParseError_Empty value)? empty,
    TResult Function(HeaderParseError_InvalidEncoding value)? invalidEncoding,
    TResult Function(HeaderParseError_InvalidFileType value)? invalidFileType,
    TResult Function(HeaderParseError_InvalidFixedHeader value)?
        invalidFixedHeader,
    TResult Function(HeaderParseError_InvalidHeaderSize value)?
        invalidHeaderSize,
    TResult Function(HeaderParseError_InvalidHeaderParts value)?
        invalidHeaderParts,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HeaderParseErrorCopyWith<$Res> {
  factory $HeaderParseErrorCopyWith(
          HeaderParseError value, $Res Function(HeaderParseError) then) =
      _$HeaderParseErrorCopyWithImpl<$Res, HeaderParseError>;
}

/// @nodoc
class _$HeaderParseErrorCopyWithImpl<$Res, $Val extends HeaderParseError>
    implements $HeaderParseErrorCopyWith<$Res> {
  _$HeaderParseErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$HeaderParseError_EmptyImplCopyWith<$Res> {
  factory _$$HeaderParseError_EmptyImplCopyWith(
          _$HeaderParseError_EmptyImpl value,
          $Res Function(_$HeaderParseError_EmptyImpl) then) =
      __$$HeaderParseError_EmptyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$HeaderParseError_EmptyImplCopyWithImpl<$Res>
    extends _$HeaderParseErrorCopyWithImpl<$Res, _$HeaderParseError_EmptyImpl>
    implements _$$HeaderParseError_EmptyImplCopyWith<$Res> {
  __$$HeaderParseError_EmptyImplCopyWithImpl(
      _$HeaderParseError_EmptyImpl _value,
      $Res Function(_$HeaderParseError_EmptyImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$HeaderParseError_EmptyImpl extends HeaderParseError_Empty {
  const _$HeaderParseError_EmptyImpl() : super._();

  @override
  String toString() {
    return 'HeaderParseError.empty()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HeaderParseError_EmptyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(String field0) invalidEncoding,
    required TResult Function(String field0) invalidFileType,
    required TResult Function() invalidFixedHeader,
    required TResult Function(int field0) invalidHeaderSize,
    required TResult Function(String field0) invalidHeaderParts,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(String field0)? invalidEncoding,
    TResult? Function(String field0)? invalidFileType,
    TResult? Function()? invalidFixedHeader,
    TResult? Function(int field0)? invalidHeaderSize,
    TResult? Function(String field0)? invalidHeaderParts,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String field0)? invalidEncoding,
    TResult Function(String field0)? invalidFileType,
    TResult Function()? invalidFixedHeader,
    TResult Function(int field0)? invalidHeaderSize,
    TResult Function(String field0)? invalidHeaderParts,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HeaderParseError_Empty value) empty,
    required TResult Function(HeaderParseError_InvalidEncoding value)
        invalidEncoding,
    required TResult Function(HeaderParseError_InvalidFileType value)
        invalidFileType,
    required TResult Function(HeaderParseError_InvalidFixedHeader value)
        invalidFixedHeader,
    required TResult Function(HeaderParseError_InvalidHeaderSize value)
        invalidHeaderSize,
    required TResult Function(HeaderParseError_InvalidHeaderParts value)
        invalidHeaderParts,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(HeaderParseError_Empty value)? empty,
    TResult? Function(HeaderParseError_InvalidEncoding value)? invalidEncoding,
    TResult? Function(HeaderParseError_InvalidFileType value)? invalidFileType,
    TResult? Function(HeaderParseError_InvalidFixedHeader value)?
        invalidFixedHeader,
    TResult? Function(HeaderParseError_InvalidHeaderSize value)?
        invalidHeaderSize,
    TResult? Function(HeaderParseError_InvalidHeaderParts value)?
        invalidHeaderParts,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HeaderParseError_Empty value)? empty,
    TResult Function(HeaderParseError_InvalidEncoding value)? invalidEncoding,
    TResult Function(HeaderParseError_InvalidFileType value)? invalidFileType,
    TResult Function(HeaderParseError_InvalidFixedHeader value)?
        invalidFixedHeader,
    TResult Function(HeaderParseError_InvalidHeaderSize value)?
        invalidHeaderSize,
    TResult Function(HeaderParseError_InvalidHeaderParts value)?
        invalidHeaderParts,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class HeaderParseError_Empty extends HeaderParseError {
  const factory HeaderParseError_Empty() = _$HeaderParseError_EmptyImpl;
  const HeaderParseError_Empty._() : super._();
}

/// @nodoc
abstract class _$$HeaderParseError_InvalidEncodingImplCopyWith<$Res> {
  factory _$$HeaderParseError_InvalidEncodingImplCopyWith(
          _$HeaderParseError_InvalidEncodingImpl value,
          $Res Function(_$HeaderParseError_InvalidEncodingImpl) then) =
      __$$HeaderParseError_InvalidEncodingImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$HeaderParseError_InvalidEncodingImplCopyWithImpl<$Res>
    extends _$HeaderParseErrorCopyWithImpl<$Res,
        _$HeaderParseError_InvalidEncodingImpl>
    implements _$$HeaderParseError_InvalidEncodingImplCopyWith<$Res> {
  __$$HeaderParseError_InvalidEncodingImplCopyWithImpl(
      _$HeaderParseError_InvalidEncodingImpl _value,
      $Res Function(_$HeaderParseError_InvalidEncodingImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$HeaderParseError_InvalidEncodingImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$HeaderParseError_InvalidEncodingImpl
    extends HeaderParseError_InvalidEncoding {
  const _$HeaderParseError_InvalidEncodingImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'HeaderParseError.invalidEncoding(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HeaderParseError_InvalidEncodingImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$HeaderParseError_InvalidEncodingImplCopyWith<
          _$HeaderParseError_InvalidEncodingImpl>
      get copyWith => __$$HeaderParseError_InvalidEncodingImplCopyWithImpl<
          _$HeaderParseError_InvalidEncodingImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(String field0) invalidEncoding,
    required TResult Function(String field0) invalidFileType,
    required TResult Function() invalidFixedHeader,
    required TResult Function(int field0) invalidHeaderSize,
    required TResult Function(String field0) invalidHeaderParts,
  }) {
    return invalidEncoding(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(String field0)? invalidEncoding,
    TResult? Function(String field0)? invalidFileType,
    TResult? Function()? invalidFixedHeader,
    TResult? Function(int field0)? invalidHeaderSize,
    TResult? Function(String field0)? invalidHeaderParts,
  }) {
    return invalidEncoding?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String field0)? invalidEncoding,
    TResult Function(String field0)? invalidFileType,
    TResult Function()? invalidFixedHeader,
    TResult Function(int field0)? invalidHeaderSize,
    TResult Function(String field0)? invalidHeaderParts,
    required TResult orElse(),
  }) {
    if (invalidEncoding != null) {
      return invalidEncoding(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HeaderParseError_Empty value) empty,
    required TResult Function(HeaderParseError_InvalidEncoding value)
        invalidEncoding,
    required TResult Function(HeaderParseError_InvalidFileType value)
        invalidFileType,
    required TResult Function(HeaderParseError_InvalidFixedHeader value)
        invalidFixedHeader,
    required TResult Function(HeaderParseError_InvalidHeaderSize value)
        invalidHeaderSize,
    required TResult Function(HeaderParseError_InvalidHeaderParts value)
        invalidHeaderParts,
  }) {
    return invalidEncoding(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(HeaderParseError_Empty value)? empty,
    TResult? Function(HeaderParseError_InvalidEncoding value)? invalidEncoding,
    TResult? Function(HeaderParseError_InvalidFileType value)? invalidFileType,
    TResult? Function(HeaderParseError_InvalidFixedHeader value)?
        invalidFixedHeader,
    TResult? Function(HeaderParseError_InvalidHeaderSize value)?
        invalidHeaderSize,
    TResult? Function(HeaderParseError_InvalidHeaderParts value)?
        invalidHeaderParts,
  }) {
    return invalidEncoding?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HeaderParseError_Empty value)? empty,
    TResult Function(HeaderParseError_InvalidEncoding value)? invalidEncoding,
    TResult Function(HeaderParseError_InvalidFileType value)? invalidFileType,
    TResult Function(HeaderParseError_InvalidFixedHeader value)?
        invalidFixedHeader,
    TResult Function(HeaderParseError_InvalidHeaderSize value)?
        invalidHeaderSize,
    TResult Function(HeaderParseError_InvalidHeaderParts value)?
        invalidHeaderParts,
    required TResult orElse(),
  }) {
    if (invalidEncoding != null) {
      return invalidEncoding(this);
    }
    return orElse();
  }
}

abstract class HeaderParseError_InvalidEncoding extends HeaderParseError {
  const factory HeaderParseError_InvalidEncoding(final String field0) =
      _$HeaderParseError_InvalidEncodingImpl;
  const HeaderParseError_InvalidEncoding._() : super._();

  String get field0;
  @JsonKey(ignore: true)
  _$$HeaderParseError_InvalidEncodingImplCopyWith<
          _$HeaderParseError_InvalidEncodingImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$HeaderParseError_InvalidFileTypeImplCopyWith<$Res> {
  factory _$$HeaderParseError_InvalidFileTypeImplCopyWith(
          _$HeaderParseError_InvalidFileTypeImpl value,
          $Res Function(_$HeaderParseError_InvalidFileTypeImpl) then) =
      __$$HeaderParseError_InvalidFileTypeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$HeaderParseError_InvalidFileTypeImplCopyWithImpl<$Res>
    extends _$HeaderParseErrorCopyWithImpl<$Res,
        _$HeaderParseError_InvalidFileTypeImpl>
    implements _$$HeaderParseError_InvalidFileTypeImplCopyWith<$Res> {
  __$$HeaderParseError_InvalidFileTypeImplCopyWithImpl(
      _$HeaderParseError_InvalidFileTypeImpl _value,
      $Res Function(_$HeaderParseError_InvalidFileTypeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$HeaderParseError_InvalidFileTypeImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$HeaderParseError_InvalidFileTypeImpl
    extends HeaderParseError_InvalidFileType {
  const _$HeaderParseError_InvalidFileTypeImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'HeaderParseError.invalidFileType(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HeaderParseError_InvalidFileTypeImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$HeaderParseError_InvalidFileTypeImplCopyWith<
          _$HeaderParseError_InvalidFileTypeImpl>
      get copyWith => __$$HeaderParseError_InvalidFileTypeImplCopyWithImpl<
          _$HeaderParseError_InvalidFileTypeImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(String field0) invalidEncoding,
    required TResult Function(String field0) invalidFileType,
    required TResult Function() invalidFixedHeader,
    required TResult Function(int field0) invalidHeaderSize,
    required TResult Function(String field0) invalidHeaderParts,
  }) {
    return invalidFileType(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(String field0)? invalidEncoding,
    TResult? Function(String field0)? invalidFileType,
    TResult? Function()? invalidFixedHeader,
    TResult? Function(int field0)? invalidHeaderSize,
    TResult? Function(String field0)? invalidHeaderParts,
  }) {
    return invalidFileType?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String field0)? invalidEncoding,
    TResult Function(String field0)? invalidFileType,
    TResult Function()? invalidFixedHeader,
    TResult Function(int field0)? invalidHeaderSize,
    TResult Function(String field0)? invalidHeaderParts,
    required TResult orElse(),
  }) {
    if (invalidFileType != null) {
      return invalidFileType(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HeaderParseError_Empty value) empty,
    required TResult Function(HeaderParseError_InvalidEncoding value)
        invalidEncoding,
    required TResult Function(HeaderParseError_InvalidFileType value)
        invalidFileType,
    required TResult Function(HeaderParseError_InvalidFixedHeader value)
        invalidFixedHeader,
    required TResult Function(HeaderParseError_InvalidHeaderSize value)
        invalidHeaderSize,
    required TResult Function(HeaderParseError_InvalidHeaderParts value)
        invalidHeaderParts,
  }) {
    return invalidFileType(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(HeaderParseError_Empty value)? empty,
    TResult? Function(HeaderParseError_InvalidEncoding value)? invalidEncoding,
    TResult? Function(HeaderParseError_InvalidFileType value)? invalidFileType,
    TResult? Function(HeaderParseError_InvalidFixedHeader value)?
        invalidFixedHeader,
    TResult? Function(HeaderParseError_InvalidHeaderSize value)?
        invalidHeaderSize,
    TResult? Function(HeaderParseError_InvalidHeaderParts value)?
        invalidHeaderParts,
  }) {
    return invalidFileType?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HeaderParseError_Empty value)? empty,
    TResult Function(HeaderParseError_InvalidEncoding value)? invalidEncoding,
    TResult Function(HeaderParseError_InvalidFileType value)? invalidFileType,
    TResult Function(HeaderParseError_InvalidFixedHeader value)?
        invalidFixedHeader,
    TResult Function(HeaderParseError_InvalidHeaderSize value)?
        invalidHeaderSize,
    TResult Function(HeaderParseError_InvalidHeaderParts value)?
        invalidHeaderParts,
    required TResult orElse(),
  }) {
    if (invalidFileType != null) {
      return invalidFileType(this);
    }
    return orElse();
  }
}

abstract class HeaderParseError_InvalidFileType extends HeaderParseError {
  const factory HeaderParseError_InvalidFileType(final String field0) =
      _$HeaderParseError_InvalidFileTypeImpl;
  const HeaderParseError_InvalidFileType._() : super._();

  String get field0;
  @JsonKey(ignore: true)
  _$$HeaderParseError_InvalidFileTypeImplCopyWith<
          _$HeaderParseError_InvalidFileTypeImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$HeaderParseError_InvalidFixedHeaderImplCopyWith<$Res> {
  factory _$$HeaderParseError_InvalidFixedHeaderImplCopyWith(
          _$HeaderParseError_InvalidFixedHeaderImpl value,
          $Res Function(_$HeaderParseError_InvalidFixedHeaderImpl) then) =
      __$$HeaderParseError_InvalidFixedHeaderImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$HeaderParseError_InvalidFixedHeaderImplCopyWithImpl<$Res>
    extends _$HeaderParseErrorCopyWithImpl<$Res,
        _$HeaderParseError_InvalidFixedHeaderImpl>
    implements _$$HeaderParseError_InvalidFixedHeaderImplCopyWith<$Res> {
  __$$HeaderParseError_InvalidFixedHeaderImplCopyWithImpl(
      _$HeaderParseError_InvalidFixedHeaderImpl _value,
      $Res Function(_$HeaderParseError_InvalidFixedHeaderImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$HeaderParseError_InvalidFixedHeaderImpl
    extends HeaderParseError_InvalidFixedHeader {
  const _$HeaderParseError_InvalidFixedHeaderImpl() : super._();

  @override
  String toString() {
    return 'HeaderParseError.invalidFixedHeader()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HeaderParseError_InvalidFixedHeaderImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(String field0) invalidEncoding,
    required TResult Function(String field0) invalidFileType,
    required TResult Function() invalidFixedHeader,
    required TResult Function(int field0) invalidHeaderSize,
    required TResult Function(String field0) invalidHeaderParts,
  }) {
    return invalidFixedHeader();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(String field0)? invalidEncoding,
    TResult? Function(String field0)? invalidFileType,
    TResult? Function()? invalidFixedHeader,
    TResult? Function(int field0)? invalidHeaderSize,
    TResult? Function(String field0)? invalidHeaderParts,
  }) {
    return invalidFixedHeader?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String field0)? invalidEncoding,
    TResult Function(String field0)? invalidFileType,
    TResult Function()? invalidFixedHeader,
    TResult Function(int field0)? invalidHeaderSize,
    TResult Function(String field0)? invalidHeaderParts,
    required TResult orElse(),
  }) {
    if (invalidFixedHeader != null) {
      return invalidFixedHeader();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HeaderParseError_Empty value) empty,
    required TResult Function(HeaderParseError_InvalidEncoding value)
        invalidEncoding,
    required TResult Function(HeaderParseError_InvalidFileType value)
        invalidFileType,
    required TResult Function(HeaderParseError_InvalidFixedHeader value)
        invalidFixedHeader,
    required TResult Function(HeaderParseError_InvalidHeaderSize value)
        invalidHeaderSize,
    required TResult Function(HeaderParseError_InvalidHeaderParts value)
        invalidHeaderParts,
  }) {
    return invalidFixedHeader(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(HeaderParseError_Empty value)? empty,
    TResult? Function(HeaderParseError_InvalidEncoding value)? invalidEncoding,
    TResult? Function(HeaderParseError_InvalidFileType value)? invalidFileType,
    TResult? Function(HeaderParseError_InvalidFixedHeader value)?
        invalidFixedHeader,
    TResult? Function(HeaderParseError_InvalidHeaderSize value)?
        invalidHeaderSize,
    TResult? Function(HeaderParseError_InvalidHeaderParts value)?
        invalidHeaderParts,
  }) {
    return invalidFixedHeader?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HeaderParseError_Empty value)? empty,
    TResult Function(HeaderParseError_InvalidEncoding value)? invalidEncoding,
    TResult Function(HeaderParseError_InvalidFileType value)? invalidFileType,
    TResult Function(HeaderParseError_InvalidFixedHeader value)?
        invalidFixedHeader,
    TResult Function(HeaderParseError_InvalidHeaderSize value)?
        invalidHeaderSize,
    TResult Function(HeaderParseError_InvalidHeaderParts value)?
        invalidHeaderParts,
    required TResult orElse(),
  }) {
    if (invalidFixedHeader != null) {
      return invalidFixedHeader(this);
    }
    return orElse();
  }
}

abstract class HeaderParseError_InvalidFixedHeader extends HeaderParseError {
  const factory HeaderParseError_InvalidFixedHeader() =
      _$HeaderParseError_InvalidFixedHeaderImpl;
  const HeaderParseError_InvalidFixedHeader._() : super._();
}

/// @nodoc
abstract class _$$HeaderParseError_InvalidHeaderSizeImplCopyWith<$Res> {
  factory _$$HeaderParseError_InvalidHeaderSizeImplCopyWith(
          _$HeaderParseError_InvalidHeaderSizeImpl value,
          $Res Function(_$HeaderParseError_InvalidHeaderSizeImpl) then) =
      __$$HeaderParseError_InvalidHeaderSizeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$HeaderParseError_InvalidHeaderSizeImplCopyWithImpl<$Res>
    extends _$HeaderParseErrorCopyWithImpl<$Res,
        _$HeaderParseError_InvalidHeaderSizeImpl>
    implements _$$HeaderParseError_InvalidHeaderSizeImplCopyWith<$Res> {
  __$$HeaderParseError_InvalidHeaderSizeImplCopyWithImpl(
      _$HeaderParseError_InvalidHeaderSizeImpl _value,
      $Res Function(_$HeaderParseError_InvalidHeaderSizeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$HeaderParseError_InvalidHeaderSizeImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$HeaderParseError_InvalidHeaderSizeImpl
    extends HeaderParseError_InvalidHeaderSize {
  const _$HeaderParseError_InvalidHeaderSizeImpl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'HeaderParseError.invalidHeaderSize(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HeaderParseError_InvalidHeaderSizeImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$HeaderParseError_InvalidHeaderSizeImplCopyWith<
          _$HeaderParseError_InvalidHeaderSizeImpl>
      get copyWith => __$$HeaderParseError_InvalidHeaderSizeImplCopyWithImpl<
          _$HeaderParseError_InvalidHeaderSizeImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(String field0) invalidEncoding,
    required TResult Function(String field0) invalidFileType,
    required TResult Function() invalidFixedHeader,
    required TResult Function(int field0) invalidHeaderSize,
    required TResult Function(String field0) invalidHeaderParts,
  }) {
    return invalidHeaderSize(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(String field0)? invalidEncoding,
    TResult? Function(String field0)? invalidFileType,
    TResult? Function()? invalidFixedHeader,
    TResult? Function(int field0)? invalidHeaderSize,
    TResult? Function(String field0)? invalidHeaderParts,
  }) {
    return invalidHeaderSize?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String field0)? invalidEncoding,
    TResult Function(String field0)? invalidFileType,
    TResult Function()? invalidFixedHeader,
    TResult Function(int field0)? invalidHeaderSize,
    TResult Function(String field0)? invalidHeaderParts,
    required TResult orElse(),
  }) {
    if (invalidHeaderSize != null) {
      return invalidHeaderSize(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HeaderParseError_Empty value) empty,
    required TResult Function(HeaderParseError_InvalidEncoding value)
        invalidEncoding,
    required TResult Function(HeaderParseError_InvalidFileType value)
        invalidFileType,
    required TResult Function(HeaderParseError_InvalidFixedHeader value)
        invalidFixedHeader,
    required TResult Function(HeaderParseError_InvalidHeaderSize value)
        invalidHeaderSize,
    required TResult Function(HeaderParseError_InvalidHeaderParts value)
        invalidHeaderParts,
  }) {
    return invalidHeaderSize(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(HeaderParseError_Empty value)? empty,
    TResult? Function(HeaderParseError_InvalidEncoding value)? invalidEncoding,
    TResult? Function(HeaderParseError_InvalidFileType value)? invalidFileType,
    TResult? Function(HeaderParseError_InvalidFixedHeader value)?
        invalidFixedHeader,
    TResult? Function(HeaderParseError_InvalidHeaderSize value)?
        invalidHeaderSize,
    TResult? Function(HeaderParseError_InvalidHeaderParts value)?
        invalidHeaderParts,
  }) {
    return invalidHeaderSize?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HeaderParseError_Empty value)? empty,
    TResult Function(HeaderParseError_InvalidEncoding value)? invalidEncoding,
    TResult Function(HeaderParseError_InvalidFileType value)? invalidFileType,
    TResult Function(HeaderParseError_InvalidFixedHeader value)?
        invalidFixedHeader,
    TResult Function(HeaderParseError_InvalidHeaderSize value)?
        invalidHeaderSize,
    TResult Function(HeaderParseError_InvalidHeaderParts value)?
        invalidHeaderParts,
    required TResult orElse(),
  }) {
    if (invalidHeaderSize != null) {
      return invalidHeaderSize(this);
    }
    return orElse();
  }
}

abstract class HeaderParseError_InvalidHeaderSize extends HeaderParseError {
  const factory HeaderParseError_InvalidHeaderSize(final int field0) =
      _$HeaderParseError_InvalidHeaderSizeImpl;
  const HeaderParseError_InvalidHeaderSize._() : super._();

  int get field0;
  @JsonKey(ignore: true)
  _$$HeaderParseError_InvalidHeaderSizeImplCopyWith<
          _$HeaderParseError_InvalidHeaderSizeImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$HeaderParseError_InvalidHeaderPartsImplCopyWith<$Res> {
  factory _$$HeaderParseError_InvalidHeaderPartsImplCopyWith(
          _$HeaderParseError_InvalidHeaderPartsImpl value,
          $Res Function(_$HeaderParseError_InvalidHeaderPartsImpl) then) =
      __$$HeaderParseError_InvalidHeaderPartsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$HeaderParseError_InvalidHeaderPartsImplCopyWithImpl<$Res>
    extends _$HeaderParseErrorCopyWithImpl<$Res,
        _$HeaderParseError_InvalidHeaderPartsImpl>
    implements _$$HeaderParseError_InvalidHeaderPartsImplCopyWith<$Res> {
  __$$HeaderParseError_InvalidHeaderPartsImplCopyWithImpl(
      _$HeaderParseError_InvalidHeaderPartsImpl _value,
      $Res Function(_$HeaderParseError_InvalidHeaderPartsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$HeaderParseError_InvalidHeaderPartsImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$HeaderParseError_InvalidHeaderPartsImpl
    extends HeaderParseError_InvalidHeaderParts {
  const _$HeaderParseError_InvalidHeaderPartsImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'HeaderParseError.invalidHeaderParts(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HeaderParseError_InvalidHeaderPartsImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$HeaderParseError_InvalidHeaderPartsImplCopyWith<
          _$HeaderParseError_InvalidHeaderPartsImpl>
      get copyWith => __$$HeaderParseError_InvalidHeaderPartsImplCopyWithImpl<
          _$HeaderParseError_InvalidHeaderPartsImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(String field0) invalidEncoding,
    required TResult Function(String field0) invalidFileType,
    required TResult Function() invalidFixedHeader,
    required TResult Function(int field0) invalidHeaderSize,
    required TResult Function(String field0) invalidHeaderParts,
  }) {
    return invalidHeaderParts(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(String field0)? invalidEncoding,
    TResult? Function(String field0)? invalidFileType,
    TResult? Function()? invalidFixedHeader,
    TResult? Function(int field0)? invalidHeaderSize,
    TResult? Function(String field0)? invalidHeaderParts,
  }) {
    return invalidHeaderParts?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String field0)? invalidEncoding,
    TResult Function(String field0)? invalidFileType,
    TResult Function()? invalidFixedHeader,
    TResult Function(int field0)? invalidHeaderSize,
    TResult Function(String field0)? invalidHeaderParts,
    required TResult orElse(),
  }) {
    if (invalidHeaderParts != null) {
      return invalidHeaderParts(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HeaderParseError_Empty value) empty,
    required TResult Function(HeaderParseError_InvalidEncoding value)
        invalidEncoding,
    required TResult Function(HeaderParseError_InvalidFileType value)
        invalidFileType,
    required TResult Function(HeaderParseError_InvalidFixedHeader value)
        invalidFixedHeader,
    required TResult Function(HeaderParseError_InvalidHeaderSize value)
        invalidHeaderSize,
    required TResult Function(HeaderParseError_InvalidHeaderParts value)
        invalidHeaderParts,
  }) {
    return invalidHeaderParts(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(HeaderParseError_Empty value)? empty,
    TResult? Function(HeaderParseError_InvalidEncoding value)? invalidEncoding,
    TResult? Function(HeaderParseError_InvalidFileType value)? invalidFileType,
    TResult? Function(HeaderParseError_InvalidFixedHeader value)?
        invalidFixedHeader,
    TResult? Function(HeaderParseError_InvalidHeaderSize value)?
        invalidHeaderSize,
    TResult? Function(HeaderParseError_InvalidHeaderParts value)?
        invalidHeaderParts,
  }) {
    return invalidHeaderParts?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HeaderParseError_Empty value)? empty,
    TResult Function(HeaderParseError_InvalidEncoding value)? invalidEncoding,
    TResult Function(HeaderParseError_InvalidFileType value)? invalidFileType,
    TResult Function(HeaderParseError_InvalidFixedHeader value)?
        invalidFixedHeader,
    TResult Function(HeaderParseError_InvalidHeaderSize value)?
        invalidHeaderSize,
    TResult Function(HeaderParseError_InvalidHeaderParts value)?
        invalidHeaderParts,
    required TResult orElse(),
  }) {
    if (invalidHeaderParts != null) {
      return invalidHeaderParts(this);
    }
    return orElse();
  }
}

abstract class HeaderParseError_InvalidHeaderParts extends HeaderParseError {
  const factory HeaderParseError_InvalidHeaderParts(final String field0) =
      _$HeaderParseError_InvalidHeaderPartsImpl;
  const HeaderParseError_InvalidHeaderParts._() : super._();

  String get field0;
  @JsonKey(ignore: true)
  _$$HeaderParseError_InvalidHeaderPartsImplCopyWith<
          _$HeaderParseError_InvalidHeaderPartsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$JoinError {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() conflictingHeaders,
    required TResult Function(int field0, int field1) tooManyParts,
    required TResult Function(int field0) duplicatePartWrongContent,
    required TResult Function(int field0) partWithNoData,
    required TResult Function(int field0) missingPart,
    required TResult Function(HeaderParseError field0) headerParseError,
    required TResult Function(DecodeError field0) decodeError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? conflictingHeaders,
    TResult? Function(int field0, int field1)? tooManyParts,
    TResult? Function(int field0)? duplicatePartWrongContent,
    TResult? Function(int field0)? partWithNoData,
    TResult? Function(int field0)? missingPart,
    TResult? Function(HeaderParseError field0)? headerParseError,
    TResult? Function(DecodeError field0)? decodeError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? conflictingHeaders,
    TResult Function(int field0, int field1)? tooManyParts,
    TResult Function(int field0)? duplicatePartWrongContent,
    TResult Function(int field0)? partWithNoData,
    TResult Function(int field0)? missingPart,
    TResult Function(HeaderParseError field0)? headerParseError,
    TResult Function(DecodeError field0)? decodeError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(JoinError_Empty value) empty,
    required TResult Function(JoinError_ConflictingHeaders value)
        conflictingHeaders,
    required TResult Function(JoinError_TooManyParts value) tooManyParts,
    required TResult Function(JoinError_DuplicatePartWrongContent value)
        duplicatePartWrongContent,
    required TResult Function(JoinError_PartWithNoData value) partWithNoData,
    required TResult Function(JoinError_MissingPart value) missingPart,
    required TResult Function(JoinError_HeaderParseError value)
        headerParseError,
    required TResult Function(JoinError_DecodeError value) decodeError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(JoinError_Empty value)? empty,
    TResult? Function(JoinError_ConflictingHeaders value)? conflictingHeaders,
    TResult? Function(JoinError_TooManyParts value)? tooManyParts,
    TResult? Function(JoinError_DuplicatePartWrongContent value)?
        duplicatePartWrongContent,
    TResult? Function(JoinError_PartWithNoData value)? partWithNoData,
    TResult? Function(JoinError_MissingPart value)? missingPart,
    TResult? Function(JoinError_HeaderParseError value)? headerParseError,
    TResult? Function(JoinError_DecodeError value)? decodeError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(JoinError_Empty value)? empty,
    TResult Function(JoinError_ConflictingHeaders value)? conflictingHeaders,
    TResult Function(JoinError_TooManyParts value)? tooManyParts,
    TResult Function(JoinError_DuplicatePartWrongContent value)?
        duplicatePartWrongContent,
    TResult Function(JoinError_PartWithNoData value)? partWithNoData,
    TResult Function(JoinError_MissingPart value)? missingPart,
    TResult Function(JoinError_HeaderParseError value)? headerParseError,
    TResult Function(JoinError_DecodeError value)? decodeError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $JoinErrorCopyWith<$Res> {
  factory $JoinErrorCopyWith(JoinError value, $Res Function(JoinError) then) =
      _$JoinErrorCopyWithImpl<$Res, JoinError>;
}

/// @nodoc
class _$JoinErrorCopyWithImpl<$Res, $Val extends JoinError>
    implements $JoinErrorCopyWith<$Res> {
  _$JoinErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$JoinError_EmptyImplCopyWith<$Res> {
  factory _$$JoinError_EmptyImplCopyWith(_$JoinError_EmptyImpl value,
          $Res Function(_$JoinError_EmptyImpl) then) =
      __$$JoinError_EmptyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$JoinError_EmptyImplCopyWithImpl<$Res>
    extends _$JoinErrorCopyWithImpl<$Res, _$JoinError_EmptyImpl>
    implements _$$JoinError_EmptyImplCopyWith<$Res> {
  __$$JoinError_EmptyImplCopyWithImpl(
      _$JoinError_EmptyImpl _value, $Res Function(_$JoinError_EmptyImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$JoinError_EmptyImpl extends JoinError_Empty {
  const _$JoinError_EmptyImpl() : super._();

  @override
  String toString() {
    return 'JoinError.empty()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$JoinError_EmptyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() conflictingHeaders,
    required TResult Function(int field0, int field1) tooManyParts,
    required TResult Function(int field0) duplicatePartWrongContent,
    required TResult Function(int field0) partWithNoData,
    required TResult Function(int field0) missingPart,
    required TResult Function(HeaderParseError field0) headerParseError,
    required TResult Function(DecodeError field0) decodeError,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? conflictingHeaders,
    TResult? Function(int field0, int field1)? tooManyParts,
    TResult? Function(int field0)? duplicatePartWrongContent,
    TResult? Function(int field0)? partWithNoData,
    TResult? Function(int field0)? missingPart,
    TResult? Function(HeaderParseError field0)? headerParseError,
    TResult? Function(DecodeError field0)? decodeError,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? conflictingHeaders,
    TResult Function(int field0, int field1)? tooManyParts,
    TResult Function(int field0)? duplicatePartWrongContent,
    TResult Function(int field0)? partWithNoData,
    TResult Function(int field0)? missingPart,
    TResult Function(HeaderParseError field0)? headerParseError,
    TResult Function(DecodeError field0)? decodeError,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(JoinError_Empty value) empty,
    required TResult Function(JoinError_ConflictingHeaders value)
        conflictingHeaders,
    required TResult Function(JoinError_TooManyParts value) tooManyParts,
    required TResult Function(JoinError_DuplicatePartWrongContent value)
        duplicatePartWrongContent,
    required TResult Function(JoinError_PartWithNoData value) partWithNoData,
    required TResult Function(JoinError_MissingPart value) missingPart,
    required TResult Function(JoinError_HeaderParseError value)
        headerParseError,
    required TResult Function(JoinError_DecodeError value) decodeError,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(JoinError_Empty value)? empty,
    TResult? Function(JoinError_ConflictingHeaders value)? conflictingHeaders,
    TResult? Function(JoinError_TooManyParts value)? tooManyParts,
    TResult? Function(JoinError_DuplicatePartWrongContent value)?
        duplicatePartWrongContent,
    TResult? Function(JoinError_PartWithNoData value)? partWithNoData,
    TResult? Function(JoinError_MissingPart value)? missingPart,
    TResult? Function(JoinError_HeaderParseError value)? headerParseError,
    TResult? Function(JoinError_DecodeError value)? decodeError,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(JoinError_Empty value)? empty,
    TResult Function(JoinError_ConflictingHeaders value)? conflictingHeaders,
    TResult Function(JoinError_TooManyParts value)? tooManyParts,
    TResult Function(JoinError_DuplicatePartWrongContent value)?
        duplicatePartWrongContent,
    TResult Function(JoinError_PartWithNoData value)? partWithNoData,
    TResult Function(JoinError_MissingPart value)? missingPart,
    TResult Function(JoinError_HeaderParseError value)? headerParseError,
    TResult Function(JoinError_DecodeError value)? decodeError,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class JoinError_Empty extends JoinError {
  const factory JoinError_Empty() = _$JoinError_EmptyImpl;
  const JoinError_Empty._() : super._();
}

/// @nodoc
abstract class _$$JoinError_ConflictingHeadersImplCopyWith<$Res> {
  factory _$$JoinError_ConflictingHeadersImplCopyWith(
          _$JoinError_ConflictingHeadersImpl value,
          $Res Function(_$JoinError_ConflictingHeadersImpl) then) =
      __$$JoinError_ConflictingHeadersImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$JoinError_ConflictingHeadersImplCopyWithImpl<$Res>
    extends _$JoinErrorCopyWithImpl<$Res, _$JoinError_ConflictingHeadersImpl>
    implements _$$JoinError_ConflictingHeadersImplCopyWith<$Res> {
  __$$JoinError_ConflictingHeadersImplCopyWithImpl(
      _$JoinError_ConflictingHeadersImpl _value,
      $Res Function(_$JoinError_ConflictingHeadersImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$JoinError_ConflictingHeadersImpl extends JoinError_ConflictingHeaders {
  const _$JoinError_ConflictingHeadersImpl() : super._();

  @override
  String toString() {
    return 'JoinError.conflictingHeaders()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$JoinError_ConflictingHeadersImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() conflictingHeaders,
    required TResult Function(int field0, int field1) tooManyParts,
    required TResult Function(int field0) duplicatePartWrongContent,
    required TResult Function(int field0) partWithNoData,
    required TResult Function(int field0) missingPart,
    required TResult Function(HeaderParseError field0) headerParseError,
    required TResult Function(DecodeError field0) decodeError,
  }) {
    return conflictingHeaders();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? conflictingHeaders,
    TResult? Function(int field0, int field1)? tooManyParts,
    TResult? Function(int field0)? duplicatePartWrongContent,
    TResult? Function(int field0)? partWithNoData,
    TResult? Function(int field0)? missingPart,
    TResult? Function(HeaderParseError field0)? headerParseError,
    TResult? Function(DecodeError field0)? decodeError,
  }) {
    return conflictingHeaders?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? conflictingHeaders,
    TResult Function(int field0, int field1)? tooManyParts,
    TResult Function(int field0)? duplicatePartWrongContent,
    TResult Function(int field0)? partWithNoData,
    TResult Function(int field0)? missingPart,
    TResult Function(HeaderParseError field0)? headerParseError,
    TResult Function(DecodeError field0)? decodeError,
    required TResult orElse(),
  }) {
    if (conflictingHeaders != null) {
      return conflictingHeaders();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(JoinError_Empty value) empty,
    required TResult Function(JoinError_ConflictingHeaders value)
        conflictingHeaders,
    required TResult Function(JoinError_TooManyParts value) tooManyParts,
    required TResult Function(JoinError_DuplicatePartWrongContent value)
        duplicatePartWrongContent,
    required TResult Function(JoinError_PartWithNoData value) partWithNoData,
    required TResult Function(JoinError_MissingPart value) missingPart,
    required TResult Function(JoinError_HeaderParseError value)
        headerParseError,
    required TResult Function(JoinError_DecodeError value) decodeError,
  }) {
    return conflictingHeaders(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(JoinError_Empty value)? empty,
    TResult? Function(JoinError_ConflictingHeaders value)? conflictingHeaders,
    TResult? Function(JoinError_TooManyParts value)? tooManyParts,
    TResult? Function(JoinError_DuplicatePartWrongContent value)?
        duplicatePartWrongContent,
    TResult? Function(JoinError_PartWithNoData value)? partWithNoData,
    TResult? Function(JoinError_MissingPart value)? missingPart,
    TResult? Function(JoinError_HeaderParseError value)? headerParseError,
    TResult? Function(JoinError_DecodeError value)? decodeError,
  }) {
    return conflictingHeaders?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(JoinError_Empty value)? empty,
    TResult Function(JoinError_ConflictingHeaders value)? conflictingHeaders,
    TResult Function(JoinError_TooManyParts value)? tooManyParts,
    TResult Function(JoinError_DuplicatePartWrongContent value)?
        duplicatePartWrongContent,
    TResult Function(JoinError_PartWithNoData value)? partWithNoData,
    TResult Function(JoinError_MissingPart value)? missingPart,
    TResult Function(JoinError_HeaderParseError value)? headerParseError,
    TResult Function(JoinError_DecodeError value)? decodeError,
    required TResult orElse(),
  }) {
    if (conflictingHeaders != null) {
      return conflictingHeaders(this);
    }
    return orElse();
  }
}

abstract class JoinError_ConflictingHeaders extends JoinError {
  const factory JoinError_ConflictingHeaders() =
      _$JoinError_ConflictingHeadersImpl;
  const JoinError_ConflictingHeaders._() : super._();
}

/// @nodoc
abstract class _$$JoinError_TooManyPartsImplCopyWith<$Res> {
  factory _$$JoinError_TooManyPartsImplCopyWith(
          _$JoinError_TooManyPartsImpl value,
          $Res Function(_$JoinError_TooManyPartsImpl) then) =
      __$$JoinError_TooManyPartsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0, int field1});
}

/// @nodoc
class __$$JoinError_TooManyPartsImplCopyWithImpl<$Res>
    extends _$JoinErrorCopyWithImpl<$Res, _$JoinError_TooManyPartsImpl>
    implements _$$JoinError_TooManyPartsImplCopyWith<$Res> {
  __$$JoinError_TooManyPartsImplCopyWithImpl(
      _$JoinError_TooManyPartsImpl _value,
      $Res Function(_$JoinError_TooManyPartsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
    Object? field1 = null,
  }) {
    return _then(_$JoinError_TooManyPartsImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
      null == field1
          ? _value.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$JoinError_TooManyPartsImpl extends JoinError_TooManyParts {
  const _$JoinError_TooManyPartsImpl(this.field0, this.field1) : super._();

  @override
  final int field0;
  @override
  final int field1;

  @override
  String toString() {
    return 'JoinError.tooManyParts(field0: $field0, field1: $field1)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$JoinError_TooManyPartsImpl &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0, field1);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$JoinError_TooManyPartsImplCopyWith<_$JoinError_TooManyPartsImpl>
      get copyWith => __$$JoinError_TooManyPartsImplCopyWithImpl<
          _$JoinError_TooManyPartsImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() conflictingHeaders,
    required TResult Function(int field0, int field1) tooManyParts,
    required TResult Function(int field0) duplicatePartWrongContent,
    required TResult Function(int field0) partWithNoData,
    required TResult Function(int field0) missingPart,
    required TResult Function(HeaderParseError field0) headerParseError,
    required TResult Function(DecodeError field0) decodeError,
  }) {
    return tooManyParts(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? conflictingHeaders,
    TResult? Function(int field0, int field1)? tooManyParts,
    TResult? Function(int field0)? duplicatePartWrongContent,
    TResult? Function(int field0)? partWithNoData,
    TResult? Function(int field0)? missingPart,
    TResult? Function(HeaderParseError field0)? headerParseError,
    TResult? Function(DecodeError field0)? decodeError,
  }) {
    return tooManyParts?.call(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? conflictingHeaders,
    TResult Function(int field0, int field1)? tooManyParts,
    TResult Function(int field0)? duplicatePartWrongContent,
    TResult Function(int field0)? partWithNoData,
    TResult Function(int field0)? missingPart,
    TResult Function(HeaderParseError field0)? headerParseError,
    TResult Function(DecodeError field0)? decodeError,
    required TResult orElse(),
  }) {
    if (tooManyParts != null) {
      return tooManyParts(field0, field1);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(JoinError_Empty value) empty,
    required TResult Function(JoinError_ConflictingHeaders value)
        conflictingHeaders,
    required TResult Function(JoinError_TooManyParts value) tooManyParts,
    required TResult Function(JoinError_DuplicatePartWrongContent value)
        duplicatePartWrongContent,
    required TResult Function(JoinError_PartWithNoData value) partWithNoData,
    required TResult Function(JoinError_MissingPart value) missingPart,
    required TResult Function(JoinError_HeaderParseError value)
        headerParseError,
    required TResult Function(JoinError_DecodeError value) decodeError,
  }) {
    return tooManyParts(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(JoinError_Empty value)? empty,
    TResult? Function(JoinError_ConflictingHeaders value)? conflictingHeaders,
    TResult? Function(JoinError_TooManyParts value)? tooManyParts,
    TResult? Function(JoinError_DuplicatePartWrongContent value)?
        duplicatePartWrongContent,
    TResult? Function(JoinError_PartWithNoData value)? partWithNoData,
    TResult? Function(JoinError_MissingPart value)? missingPart,
    TResult? Function(JoinError_HeaderParseError value)? headerParseError,
    TResult? Function(JoinError_DecodeError value)? decodeError,
  }) {
    return tooManyParts?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(JoinError_Empty value)? empty,
    TResult Function(JoinError_ConflictingHeaders value)? conflictingHeaders,
    TResult Function(JoinError_TooManyParts value)? tooManyParts,
    TResult Function(JoinError_DuplicatePartWrongContent value)?
        duplicatePartWrongContent,
    TResult Function(JoinError_PartWithNoData value)? partWithNoData,
    TResult Function(JoinError_MissingPart value)? missingPart,
    TResult Function(JoinError_HeaderParseError value)? headerParseError,
    TResult Function(JoinError_DecodeError value)? decodeError,
    required TResult orElse(),
  }) {
    if (tooManyParts != null) {
      return tooManyParts(this);
    }
    return orElse();
  }
}

abstract class JoinError_TooManyParts extends JoinError {
  const factory JoinError_TooManyParts(final int field0, final int field1) =
      _$JoinError_TooManyPartsImpl;
  const JoinError_TooManyParts._() : super._();

  int get field0;
  int get field1;
  @JsonKey(ignore: true)
  _$$JoinError_TooManyPartsImplCopyWith<_$JoinError_TooManyPartsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$JoinError_DuplicatePartWrongContentImplCopyWith<$Res> {
  factory _$$JoinError_DuplicatePartWrongContentImplCopyWith(
          _$JoinError_DuplicatePartWrongContentImpl value,
          $Res Function(_$JoinError_DuplicatePartWrongContentImpl) then) =
      __$$JoinError_DuplicatePartWrongContentImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$JoinError_DuplicatePartWrongContentImplCopyWithImpl<$Res>
    extends _$JoinErrorCopyWithImpl<$Res,
        _$JoinError_DuplicatePartWrongContentImpl>
    implements _$$JoinError_DuplicatePartWrongContentImplCopyWith<$Res> {
  __$$JoinError_DuplicatePartWrongContentImplCopyWithImpl(
      _$JoinError_DuplicatePartWrongContentImpl _value,
      $Res Function(_$JoinError_DuplicatePartWrongContentImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$JoinError_DuplicatePartWrongContentImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$JoinError_DuplicatePartWrongContentImpl
    extends JoinError_DuplicatePartWrongContent {
  const _$JoinError_DuplicatePartWrongContentImpl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'JoinError.duplicatePartWrongContent(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$JoinError_DuplicatePartWrongContentImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$JoinError_DuplicatePartWrongContentImplCopyWith<
          _$JoinError_DuplicatePartWrongContentImpl>
      get copyWith => __$$JoinError_DuplicatePartWrongContentImplCopyWithImpl<
          _$JoinError_DuplicatePartWrongContentImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() conflictingHeaders,
    required TResult Function(int field0, int field1) tooManyParts,
    required TResult Function(int field0) duplicatePartWrongContent,
    required TResult Function(int field0) partWithNoData,
    required TResult Function(int field0) missingPart,
    required TResult Function(HeaderParseError field0) headerParseError,
    required TResult Function(DecodeError field0) decodeError,
  }) {
    return duplicatePartWrongContent(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? conflictingHeaders,
    TResult? Function(int field0, int field1)? tooManyParts,
    TResult? Function(int field0)? duplicatePartWrongContent,
    TResult? Function(int field0)? partWithNoData,
    TResult? Function(int field0)? missingPart,
    TResult? Function(HeaderParseError field0)? headerParseError,
    TResult? Function(DecodeError field0)? decodeError,
  }) {
    return duplicatePartWrongContent?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? conflictingHeaders,
    TResult Function(int field0, int field1)? tooManyParts,
    TResult Function(int field0)? duplicatePartWrongContent,
    TResult Function(int field0)? partWithNoData,
    TResult Function(int field0)? missingPart,
    TResult Function(HeaderParseError field0)? headerParseError,
    TResult Function(DecodeError field0)? decodeError,
    required TResult orElse(),
  }) {
    if (duplicatePartWrongContent != null) {
      return duplicatePartWrongContent(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(JoinError_Empty value) empty,
    required TResult Function(JoinError_ConflictingHeaders value)
        conflictingHeaders,
    required TResult Function(JoinError_TooManyParts value) tooManyParts,
    required TResult Function(JoinError_DuplicatePartWrongContent value)
        duplicatePartWrongContent,
    required TResult Function(JoinError_PartWithNoData value) partWithNoData,
    required TResult Function(JoinError_MissingPart value) missingPart,
    required TResult Function(JoinError_HeaderParseError value)
        headerParseError,
    required TResult Function(JoinError_DecodeError value) decodeError,
  }) {
    return duplicatePartWrongContent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(JoinError_Empty value)? empty,
    TResult? Function(JoinError_ConflictingHeaders value)? conflictingHeaders,
    TResult? Function(JoinError_TooManyParts value)? tooManyParts,
    TResult? Function(JoinError_DuplicatePartWrongContent value)?
        duplicatePartWrongContent,
    TResult? Function(JoinError_PartWithNoData value)? partWithNoData,
    TResult? Function(JoinError_MissingPart value)? missingPart,
    TResult? Function(JoinError_HeaderParseError value)? headerParseError,
    TResult? Function(JoinError_DecodeError value)? decodeError,
  }) {
    return duplicatePartWrongContent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(JoinError_Empty value)? empty,
    TResult Function(JoinError_ConflictingHeaders value)? conflictingHeaders,
    TResult Function(JoinError_TooManyParts value)? tooManyParts,
    TResult Function(JoinError_DuplicatePartWrongContent value)?
        duplicatePartWrongContent,
    TResult Function(JoinError_PartWithNoData value)? partWithNoData,
    TResult Function(JoinError_MissingPart value)? missingPart,
    TResult Function(JoinError_HeaderParseError value)? headerParseError,
    TResult Function(JoinError_DecodeError value)? decodeError,
    required TResult orElse(),
  }) {
    if (duplicatePartWrongContent != null) {
      return duplicatePartWrongContent(this);
    }
    return orElse();
  }
}

abstract class JoinError_DuplicatePartWrongContent extends JoinError {
  const factory JoinError_DuplicatePartWrongContent(final int field0) =
      _$JoinError_DuplicatePartWrongContentImpl;
  const JoinError_DuplicatePartWrongContent._() : super._();

  int get field0;
  @JsonKey(ignore: true)
  _$$JoinError_DuplicatePartWrongContentImplCopyWith<
          _$JoinError_DuplicatePartWrongContentImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$JoinError_PartWithNoDataImplCopyWith<$Res> {
  factory _$$JoinError_PartWithNoDataImplCopyWith(
          _$JoinError_PartWithNoDataImpl value,
          $Res Function(_$JoinError_PartWithNoDataImpl) then) =
      __$$JoinError_PartWithNoDataImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$JoinError_PartWithNoDataImplCopyWithImpl<$Res>
    extends _$JoinErrorCopyWithImpl<$Res, _$JoinError_PartWithNoDataImpl>
    implements _$$JoinError_PartWithNoDataImplCopyWith<$Res> {
  __$$JoinError_PartWithNoDataImplCopyWithImpl(
      _$JoinError_PartWithNoDataImpl _value,
      $Res Function(_$JoinError_PartWithNoDataImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$JoinError_PartWithNoDataImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$JoinError_PartWithNoDataImpl extends JoinError_PartWithNoData {
  const _$JoinError_PartWithNoDataImpl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'JoinError.partWithNoData(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$JoinError_PartWithNoDataImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$JoinError_PartWithNoDataImplCopyWith<_$JoinError_PartWithNoDataImpl>
      get copyWith => __$$JoinError_PartWithNoDataImplCopyWithImpl<
          _$JoinError_PartWithNoDataImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() conflictingHeaders,
    required TResult Function(int field0, int field1) tooManyParts,
    required TResult Function(int field0) duplicatePartWrongContent,
    required TResult Function(int field0) partWithNoData,
    required TResult Function(int field0) missingPart,
    required TResult Function(HeaderParseError field0) headerParseError,
    required TResult Function(DecodeError field0) decodeError,
  }) {
    return partWithNoData(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? conflictingHeaders,
    TResult? Function(int field0, int field1)? tooManyParts,
    TResult? Function(int field0)? duplicatePartWrongContent,
    TResult? Function(int field0)? partWithNoData,
    TResult? Function(int field0)? missingPart,
    TResult? Function(HeaderParseError field0)? headerParseError,
    TResult? Function(DecodeError field0)? decodeError,
  }) {
    return partWithNoData?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? conflictingHeaders,
    TResult Function(int field0, int field1)? tooManyParts,
    TResult Function(int field0)? duplicatePartWrongContent,
    TResult Function(int field0)? partWithNoData,
    TResult Function(int field0)? missingPart,
    TResult Function(HeaderParseError field0)? headerParseError,
    TResult Function(DecodeError field0)? decodeError,
    required TResult orElse(),
  }) {
    if (partWithNoData != null) {
      return partWithNoData(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(JoinError_Empty value) empty,
    required TResult Function(JoinError_ConflictingHeaders value)
        conflictingHeaders,
    required TResult Function(JoinError_TooManyParts value) tooManyParts,
    required TResult Function(JoinError_DuplicatePartWrongContent value)
        duplicatePartWrongContent,
    required TResult Function(JoinError_PartWithNoData value) partWithNoData,
    required TResult Function(JoinError_MissingPart value) missingPart,
    required TResult Function(JoinError_HeaderParseError value)
        headerParseError,
    required TResult Function(JoinError_DecodeError value) decodeError,
  }) {
    return partWithNoData(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(JoinError_Empty value)? empty,
    TResult? Function(JoinError_ConflictingHeaders value)? conflictingHeaders,
    TResult? Function(JoinError_TooManyParts value)? tooManyParts,
    TResult? Function(JoinError_DuplicatePartWrongContent value)?
        duplicatePartWrongContent,
    TResult? Function(JoinError_PartWithNoData value)? partWithNoData,
    TResult? Function(JoinError_MissingPart value)? missingPart,
    TResult? Function(JoinError_HeaderParseError value)? headerParseError,
    TResult? Function(JoinError_DecodeError value)? decodeError,
  }) {
    return partWithNoData?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(JoinError_Empty value)? empty,
    TResult Function(JoinError_ConflictingHeaders value)? conflictingHeaders,
    TResult Function(JoinError_TooManyParts value)? tooManyParts,
    TResult Function(JoinError_DuplicatePartWrongContent value)?
        duplicatePartWrongContent,
    TResult Function(JoinError_PartWithNoData value)? partWithNoData,
    TResult Function(JoinError_MissingPart value)? missingPart,
    TResult Function(JoinError_HeaderParseError value)? headerParseError,
    TResult Function(JoinError_DecodeError value)? decodeError,
    required TResult orElse(),
  }) {
    if (partWithNoData != null) {
      return partWithNoData(this);
    }
    return orElse();
  }
}

abstract class JoinError_PartWithNoData extends JoinError {
  const factory JoinError_PartWithNoData(final int field0) =
      _$JoinError_PartWithNoDataImpl;
  const JoinError_PartWithNoData._() : super._();

  int get field0;
  @JsonKey(ignore: true)
  _$$JoinError_PartWithNoDataImplCopyWith<_$JoinError_PartWithNoDataImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$JoinError_MissingPartImplCopyWith<$Res> {
  factory _$$JoinError_MissingPartImplCopyWith(
          _$JoinError_MissingPartImpl value,
          $Res Function(_$JoinError_MissingPartImpl) then) =
      __$$JoinError_MissingPartImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$JoinError_MissingPartImplCopyWithImpl<$Res>
    extends _$JoinErrorCopyWithImpl<$Res, _$JoinError_MissingPartImpl>
    implements _$$JoinError_MissingPartImplCopyWith<$Res> {
  __$$JoinError_MissingPartImplCopyWithImpl(_$JoinError_MissingPartImpl _value,
      $Res Function(_$JoinError_MissingPartImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$JoinError_MissingPartImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$JoinError_MissingPartImpl extends JoinError_MissingPart {
  const _$JoinError_MissingPartImpl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'JoinError.missingPart(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$JoinError_MissingPartImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$JoinError_MissingPartImplCopyWith<_$JoinError_MissingPartImpl>
      get copyWith => __$$JoinError_MissingPartImplCopyWithImpl<
          _$JoinError_MissingPartImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() conflictingHeaders,
    required TResult Function(int field0, int field1) tooManyParts,
    required TResult Function(int field0) duplicatePartWrongContent,
    required TResult Function(int field0) partWithNoData,
    required TResult Function(int field0) missingPart,
    required TResult Function(HeaderParseError field0) headerParseError,
    required TResult Function(DecodeError field0) decodeError,
  }) {
    return missingPart(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? conflictingHeaders,
    TResult? Function(int field0, int field1)? tooManyParts,
    TResult? Function(int field0)? duplicatePartWrongContent,
    TResult? Function(int field0)? partWithNoData,
    TResult? Function(int field0)? missingPart,
    TResult? Function(HeaderParseError field0)? headerParseError,
    TResult? Function(DecodeError field0)? decodeError,
  }) {
    return missingPart?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? conflictingHeaders,
    TResult Function(int field0, int field1)? tooManyParts,
    TResult Function(int field0)? duplicatePartWrongContent,
    TResult Function(int field0)? partWithNoData,
    TResult Function(int field0)? missingPart,
    TResult Function(HeaderParseError field0)? headerParseError,
    TResult Function(DecodeError field0)? decodeError,
    required TResult orElse(),
  }) {
    if (missingPart != null) {
      return missingPart(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(JoinError_Empty value) empty,
    required TResult Function(JoinError_ConflictingHeaders value)
        conflictingHeaders,
    required TResult Function(JoinError_TooManyParts value) tooManyParts,
    required TResult Function(JoinError_DuplicatePartWrongContent value)
        duplicatePartWrongContent,
    required TResult Function(JoinError_PartWithNoData value) partWithNoData,
    required TResult Function(JoinError_MissingPart value) missingPart,
    required TResult Function(JoinError_HeaderParseError value)
        headerParseError,
    required TResult Function(JoinError_DecodeError value) decodeError,
  }) {
    return missingPart(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(JoinError_Empty value)? empty,
    TResult? Function(JoinError_ConflictingHeaders value)? conflictingHeaders,
    TResult? Function(JoinError_TooManyParts value)? tooManyParts,
    TResult? Function(JoinError_DuplicatePartWrongContent value)?
        duplicatePartWrongContent,
    TResult? Function(JoinError_PartWithNoData value)? partWithNoData,
    TResult? Function(JoinError_MissingPart value)? missingPart,
    TResult? Function(JoinError_HeaderParseError value)? headerParseError,
    TResult? Function(JoinError_DecodeError value)? decodeError,
  }) {
    return missingPart?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(JoinError_Empty value)? empty,
    TResult Function(JoinError_ConflictingHeaders value)? conflictingHeaders,
    TResult Function(JoinError_TooManyParts value)? tooManyParts,
    TResult Function(JoinError_DuplicatePartWrongContent value)?
        duplicatePartWrongContent,
    TResult Function(JoinError_PartWithNoData value)? partWithNoData,
    TResult Function(JoinError_MissingPart value)? missingPart,
    TResult Function(JoinError_HeaderParseError value)? headerParseError,
    TResult Function(JoinError_DecodeError value)? decodeError,
    required TResult orElse(),
  }) {
    if (missingPart != null) {
      return missingPart(this);
    }
    return orElse();
  }
}

abstract class JoinError_MissingPart extends JoinError {
  const factory JoinError_MissingPart(final int field0) =
      _$JoinError_MissingPartImpl;
  const JoinError_MissingPart._() : super._();

  int get field0;
  @JsonKey(ignore: true)
  _$$JoinError_MissingPartImplCopyWith<_$JoinError_MissingPartImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$JoinError_HeaderParseErrorImplCopyWith<$Res> {
  factory _$$JoinError_HeaderParseErrorImplCopyWith(
          _$JoinError_HeaderParseErrorImpl value,
          $Res Function(_$JoinError_HeaderParseErrorImpl) then) =
      __$$JoinError_HeaderParseErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({HeaderParseError field0});

  $HeaderParseErrorCopyWith<$Res> get field0;
}

/// @nodoc
class __$$JoinError_HeaderParseErrorImplCopyWithImpl<$Res>
    extends _$JoinErrorCopyWithImpl<$Res, _$JoinError_HeaderParseErrorImpl>
    implements _$$JoinError_HeaderParseErrorImplCopyWith<$Res> {
  __$$JoinError_HeaderParseErrorImplCopyWithImpl(
      _$JoinError_HeaderParseErrorImpl _value,
      $Res Function(_$JoinError_HeaderParseErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$JoinError_HeaderParseErrorImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as HeaderParseError,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $HeaderParseErrorCopyWith<$Res> get field0 {
    return $HeaderParseErrorCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$JoinError_HeaderParseErrorImpl extends JoinError_HeaderParseError {
  const _$JoinError_HeaderParseErrorImpl(this.field0) : super._();

  @override
  final HeaderParseError field0;

  @override
  String toString() {
    return 'JoinError.headerParseError(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$JoinError_HeaderParseErrorImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$JoinError_HeaderParseErrorImplCopyWith<_$JoinError_HeaderParseErrorImpl>
      get copyWith => __$$JoinError_HeaderParseErrorImplCopyWithImpl<
          _$JoinError_HeaderParseErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() conflictingHeaders,
    required TResult Function(int field0, int field1) tooManyParts,
    required TResult Function(int field0) duplicatePartWrongContent,
    required TResult Function(int field0) partWithNoData,
    required TResult Function(int field0) missingPart,
    required TResult Function(HeaderParseError field0) headerParseError,
    required TResult Function(DecodeError field0) decodeError,
  }) {
    return headerParseError(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? conflictingHeaders,
    TResult? Function(int field0, int field1)? tooManyParts,
    TResult? Function(int field0)? duplicatePartWrongContent,
    TResult? Function(int field0)? partWithNoData,
    TResult? Function(int field0)? missingPart,
    TResult? Function(HeaderParseError field0)? headerParseError,
    TResult? Function(DecodeError field0)? decodeError,
  }) {
    return headerParseError?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? conflictingHeaders,
    TResult Function(int field0, int field1)? tooManyParts,
    TResult Function(int field0)? duplicatePartWrongContent,
    TResult Function(int field0)? partWithNoData,
    TResult Function(int field0)? missingPart,
    TResult Function(HeaderParseError field0)? headerParseError,
    TResult Function(DecodeError field0)? decodeError,
    required TResult orElse(),
  }) {
    if (headerParseError != null) {
      return headerParseError(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(JoinError_Empty value) empty,
    required TResult Function(JoinError_ConflictingHeaders value)
        conflictingHeaders,
    required TResult Function(JoinError_TooManyParts value) tooManyParts,
    required TResult Function(JoinError_DuplicatePartWrongContent value)
        duplicatePartWrongContent,
    required TResult Function(JoinError_PartWithNoData value) partWithNoData,
    required TResult Function(JoinError_MissingPart value) missingPart,
    required TResult Function(JoinError_HeaderParseError value)
        headerParseError,
    required TResult Function(JoinError_DecodeError value) decodeError,
  }) {
    return headerParseError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(JoinError_Empty value)? empty,
    TResult? Function(JoinError_ConflictingHeaders value)? conflictingHeaders,
    TResult? Function(JoinError_TooManyParts value)? tooManyParts,
    TResult? Function(JoinError_DuplicatePartWrongContent value)?
        duplicatePartWrongContent,
    TResult? Function(JoinError_PartWithNoData value)? partWithNoData,
    TResult? Function(JoinError_MissingPart value)? missingPart,
    TResult? Function(JoinError_HeaderParseError value)? headerParseError,
    TResult? Function(JoinError_DecodeError value)? decodeError,
  }) {
    return headerParseError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(JoinError_Empty value)? empty,
    TResult Function(JoinError_ConflictingHeaders value)? conflictingHeaders,
    TResult Function(JoinError_TooManyParts value)? tooManyParts,
    TResult Function(JoinError_DuplicatePartWrongContent value)?
        duplicatePartWrongContent,
    TResult Function(JoinError_PartWithNoData value)? partWithNoData,
    TResult Function(JoinError_MissingPart value)? missingPart,
    TResult Function(JoinError_HeaderParseError value)? headerParseError,
    TResult Function(JoinError_DecodeError value)? decodeError,
    required TResult orElse(),
  }) {
    if (headerParseError != null) {
      return headerParseError(this);
    }
    return orElse();
  }
}

abstract class JoinError_HeaderParseError extends JoinError {
  const factory JoinError_HeaderParseError(final HeaderParseError field0) =
      _$JoinError_HeaderParseErrorImpl;
  const JoinError_HeaderParseError._() : super._();

  HeaderParseError get field0;
  @JsonKey(ignore: true)
  _$$JoinError_HeaderParseErrorImplCopyWith<_$JoinError_HeaderParseErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$JoinError_DecodeErrorImplCopyWith<$Res> {
  factory _$$JoinError_DecodeErrorImplCopyWith(
          _$JoinError_DecodeErrorImpl value,
          $Res Function(_$JoinError_DecodeErrorImpl) then) =
      __$$JoinError_DecodeErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({DecodeError field0});

  $DecodeErrorCopyWith<$Res> get field0;
}

/// @nodoc
class __$$JoinError_DecodeErrorImplCopyWithImpl<$Res>
    extends _$JoinErrorCopyWithImpl<$Res, _$JoinError_DecodeErrorImpl>
    implements _$$JoinError_DecodeErrorImplCopyWith<$Res> {
  __$$JoinError_DecodeErrorImplCopyWithImpl(_$JoinError_DecodeErrorImpl _value,
      $Res Function(_$JoinError_DecodeErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$JoinError_DecodeErrorImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as DecodeError,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $DecodeErrorCopyWith<$Res> get field0 {
    return $DecodeErrorCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$JoinError_DecodeErrorImpl extends JoinError_DecodeError {
  const _$JoinError_DecodeErrorImpl(this.field0) : super._();

  @override
  final DecodeError field0;

  @override
  String toString() {
    return 'JoinError.decodeError(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$JoinError_DecodeErrorImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$JoinError_DecodeErrorImplCopyWith<_$JoinError_DecodeErrorImpl>
      get copyWith => __$$JoinError_DecodeErrorImplCopyWithImpl<
          _$JoinError_DecodeErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() conflictingHeaders,
    required TResult Function(int field0, int field1) tooManyParts,
    required TResult Function(int field0) duplicatePartWrongContent,
    required TResult Function(int field0) partWithNoData,
    required TResult Function(int field0) missingPart,
    required TResult Function(HeaderParseError field0) headerParseError,
    required TResult Function(DecodeError field0) decodeError,
  }) {
    return decodeError(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? conflictingHeaders,
    TResult? Function(int field0, int field1)? tooManyParts,
    TResult? Function(int field0)? duplicatePartWrongContent,
    TResult? Function(int field0)? partWithNoData,
    TResult? Function(int field0)? missingPart,
    TResult? Function(HeaderParseError field0)? headerParseError,
    TResult? Function(DecodeError field0)? decodeError,
  }) {
    return decodeError?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? conflictingHeaders,
    TResult Function(int field0, int field1)? tooManyParts,
    TResult Function(int field0)? duplicatePartWrongContent,
    TResult Function(int field0)? partWithNoData,
    TResult Function(int field0)? missingPart,
    TResult Function(HeaderParseError field0)? headerParseError,
    TResult Function(DecodeError field0)? decodeError,
    required TResult orElse(),
  }) {
    if (decodeError != null) {
      return decodeError(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(JoinError_Empty value) empty,
    required TResult Function(JoinError_ConflictingHeaders value)
        conflictingHeaders,
    required TResult Function(JoinError_TooManyParts value) tooManyParts,
    required TResult Function(JoinError_DuplicatePartWrongContent value)
        duplicatePartWrongContent,
    required TResult Function(JoinError_PartWithNoData value) partWithNoData,
    required TResult Function(JoinError_MissingPart value) missingPart,
    required TResult Function(JoinError_HeaderParseError value)
        headerParseError,
    required TResult Function(JoinError_DecodeError value) decodeError,
  }) {
    return decodeError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(JoinError_Empty value)? empty,
    TResult? Function(JoinError_ConflictingHeaders value)? conflictingHeaders,
    TResult? Function(JoinError_TooManyParts value)? tooManyParts,
    TResult? Function(JoinError_DuplicatePartWrongContent value)?
        duplicatePartWrongContent,
    TResult? Function(JoinError_PartWithNoData value)? partWithNoData,
    TResult? Function(JoinError_MissingPart value)? missingPart,
    TResult? Function(JoinError_HeaderParseError value)? headerParseError,
    TResult? Function(JoinError_DecodeError value)? decodeError,
  }) {
    return decodeError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(JoinError_Empty value)? empty,
    TResult Function(JoinError_ConflictingHeaders value)? conflictingHeaders,
    TResult Function(JoinError_TooManyParts value)? tooManyParts,
    TResult Function(JoinError_DuplicatePartWrongContent value)?
        duplicatePartWrongContent,
    TResult Function(JoinError_PartWithNoData value)? partWithNoData,
    TResult Function(JoinError_MissingPart value)? missingPart,
    TResult Function(JoinError_HeaderParseError value)? headerParseError,
    TResult Function(JoinError_DecodeError value)? decodeError,
    required TResult orElse(),
  }) {
    if (decodeError != null) {
      return decodeError(this);
    }
    return orElse();
  }
}

abstract class JoinError_DecodeError extends JoinError {
  const factory JoinError_DecodeError(final DecodeError field0) =
      _$JoinError_DecodeErrorImpl;
  const JoinError_DecodeError._() : super._();

  DecodeError get field0;
  @JsonKey(ignore: true)
  _$$JoinError_DecodeErrorImplCopyWith<_$JoinError_DecodeErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SplitError {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() cannotFit,
    required TResult Function(int field0) maxSplitSizeTooLarge,
    required TResult Function() minSplitTooSmall,
    required TResult Function() invalidSplitRange,
    required TResult Function() invalidVersionRange,
    required TResult Function(EncodeError field0) encodeError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? cannotFit,
    TResult? Function(int field0)? maxSplitSizeTooLarge,
    TResult? Function()? minSplitTooSmall,
    TResult? Function()? invalidSplitRange,
    TResult? Function()? invalidVersionRange,
    TResult? Function(EncodeError field0)? encodeError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? cannotFit,
    TResult Function(int field0)? maxSplitSizeTooLarge,
    TResult Function()? minSplitTooSmall,
    TResult Function()? invalidSplitRange,
    TResult Function()? invalidVersionRange,
    TResult Function(EncodeError field0)? encodeError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SplitError_Empty value) empty,
    required TResult Function(SplitError_CannotFit value) cannotFit,
    required TResult Function(SplitError_MaxSplitSizeTooLarge value)
        maxSplitSizeTooLarge,
    required TResult Function(SplitError_MinSplitTooSmall value)
        minSplitTooSmall,
    required TResult Function(SplitError_InvalidSplitRange value)
        invalidSplitRange,
    required TResult Function(SplitError_InvalidVersionRange value)
        invalidVersionRange,
    required TResult Function(SplitError_EncodeError value) encodeError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SplitError_Empty value)? empty,
    TResult? Function(SplitError_CannotFit value)? cannotFit,
    TResult? Function(SplitError_MaxSplitSizeTooLarge value)?
        maxSplitSizeTooLarge,
    TResult? Function(SplitError_MinSplitTooSmall value)? minSplitTooSmall,
    TResult? Function(SplitError_InvalidSplitRange value)? invalidSplitRange,
    TResult? Function(SplitError_InvalidVersionRange value)?
        invalidVersionRange,
    TResult? Function(SplitError_EncodeError value)? encodeError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SplitError_Empty value)? empty,
    TResult Function(SplitError_CannotFit value)? cannotFit,
    TResult Function(SplitError_MaxSplitSizeTooLarge value)?
        maxSplitSizeTooLarge,
    TResult Function(SplitError_MinSplitTooSmall value)? minSplitTooSmall,
    TResult Function(SplitError_InvalidSplitRange value)? invalidSplitRange,
    TResult Function(SplitError_InvalidVersionRange value)? invalidVersionRange,
    TResult Function(SplitError_EncodeError value)? encodeError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SplitErrorCopyWith<$Res> {
  factory $SplitErrorCopyWith(
          SplitError value, $Res Function(SplitError) then) =
      _$SplitErrorCopyWithImpl<$Res, SplitError>;
}

/// @nodoc
class _$SplitErrorCopyWithImpl<$Res, $Val extends SplitError>
    implements $SplitErrorCopyWith<$Res> {
  _$SplitErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$SplitError_EmptyImplCopyWith<$Res> {
  factory _$$SplitError_EmptyImplCopyWith(_$SplitError_EmptyImpl value,
          $Res Function(_$SplitError_EmptyImpl) then) =
      __$$SplitError_EmptyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SplitError_EmptyImplCopyWithImpl<$Res>
    extends _$SplitErrorCopyWithImpl<$Res, _$SplitError_EmptyImpl>
    implements _$$SplitError_EmptyImplCopyWith<$Res> {
  __$$SplitError_EmptyImplCopyWithImpl(_$SplitError_EmptyImpl _value,
      $Res Function(_$SplitError_EmptyImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SplitError_EmptyImpl extends SplitError_Empty {
  const _$SplitError_EmptyImpl() : super._();

  @override
  String toString() {
    return 'SplitError.empty()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SplitError_EmptyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() cannotFit,
    required TResult Function(int field0) maxSplitSizeTooLarge,
    required TResult Function() minSplitTooSmall,
    required TResult Function() invalidSplitRange,
    required TResult Function() invalidVersionRange,
    required TResult Function(EncodeError field0) encodeError,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? cannotFit,
    TResult? Function(int field0)? maxSplitSizeTooLarge,
    TResult? Function()? minSplitTooSmall,
    TResult? Function()? invalidSplitRange,
    TResult? Function()? invalidVersionRange,
    TResult? Function(EncodeError field0)? encodeError,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? cannotFit,
    TResult Function(int field0)? maxSplitSizeTooLarge,
    TResult Function()? minSplitTooSmall,
    TResult Function()? invalidSplitRange,
    TResult Function()? invalidVersionRange,
    TResult Function(EncodeError field0)? encodeError,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SplitError_Empty value) empty,
    required TResult Function(SplitError_CannotFit value) cannotFit,
    required TResult Function(SplitError_MaxSplitSizeTooLarge value)
        maxSplitSizeTooLarge,
    required TResult Function(SplitError_MinSplitTooSmall value)
        minSplitTooSmall,
    required TResult Function(SplitError_InvalidSplitRange value)
        invalidSplitRange,
    required TResult Function(SplitError_InvalidVersionRange value)
        invalidVersionRange,
    required TResult Function(SplitError_EncodeError value) encodeError,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SplitError_Empty value)? empty,
    TResult? Function(SplitError_CannotFit value)? cannotFit,
    TResult? Function(SplitError_MaxSplitSizeTooLarge value)?
        maxSplitSizeTooLarge,
    TResult? Function(SplitError_MinSplitTooSmall value)? minSplitTooSmall,
    TResult? Function(SplitError_InvalidSplitRange value)? invalidSplitRange,
    TResult? Function(SplitError_InvalidVersionRange value)?
        invalidVersionRange,
    TResult? Function(SplitError_EncodeError value)? encodeError,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SplitError_Empty value)? empty,
    TResult Function(SplitError_CannotFit value)? cannotFit,
    TResult Function(SplitError_MaxSplitSizeTooLarge value)?
        maxSplitSizeTooLarge,
    TResult Function(SplitError_MinSplitTooSmall value)? minSplitTooSmall,
    TResult Function(SplitError_InvalidSplitRange value)? invalidSplitRange,
    TResult Function(SplitError_InvalidVersionRange value)? invalidVersionRange,
    TResult Function(SplitError_EncodeError value)? encodeError,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class SplitError_Empty extends SplitError {
  const factory SplitError_Empty() = _$SplitError_EmptyImpl;
  const SplitError_Empty._() : super._();
}

/// @nodoc
abstract class _$$SplitError_CannotFitImplCopyWith<$Res> {
  factory _$$SplitError_CannotFitImplCopyWith(_$SplitError_CannotFitImpl value,
          $Res Function(_$SplitError_CannotFitImpl) then) =
      __$$SplitError_CannotFitImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SplitError_CannotFitImplCopyWithImpl<$Res>
    extends _$SplitErrorCopyWithImpl<$Res, _$SplitError_CannotFitImpl>
    implements _$$SplitError_CannotFitImplCopyWith<$Res> {
  __$$SplitError_CannotFitImplCopyWithImpl(_$SplitError_CannotFitImpl _value,
      $Res Function(_$SplitError_CannotFitImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SplitError_CannotFitImpl extends SplitError_CannotFit {
  const _$SplitError_CannotFitImpl() : super._();

  @override
  String toString() {
    return 'SplitError.cannotFit()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SplitError_CannotFitImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() cannotFit,
    required TResult Function(int field0) maxSplitSizeTooLarge,
    required TResult Function() minSplitTooSmall,
    required TResult Function() invalidSplitRange,
    required TResult Function() invalidVersionRange,
    required TResult Function(EncodeError field0) encodeError,
  }) {
    return cannotFit();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? cannotFit,
    TResult? Function(int field0)? maxSplitSizeTooLarge,
    TResult? Function()? minSplitTooSmall,
    TResult? Function()? invalidSplitRange,
    TResult? Function()? invalidVersionRange,
    TResult? Function(EncodeError field0)? encodeError,
  }) {
    return cannotFit?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? cannotFit,
    TResult Function(int field0)? maxSplitSizeTooLarge,
    TResult Function()? minSplitTooSmall,
    TResult Function()? invalidSplitRange,
    TResult Function()? invalidVersionRange,
    TResult Function(EncodeError field0)? encodeError,
    required TResult orElse(),
  }) {
    if (cannotFit != null) {
      return cannotFit();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SplitError_Empty value) empty,
    required TResult Function(SplitError_CannotFit value) cannotFit,
    required TResult Function(SplitError_MaxSplitSizeTooLarge value)
        maxSplitSizeTooLarge,
    required TResult Function(SplitError_MinSplitTooSmall value)
        minSplitTooSmall,
    required TResult Function(SplitError_InvalidSplitRange value)
        invalidSplitRange,
    required TResult Function(SplitError_InvalidVersionRange value)
        invalidVersionRange,
    required TResult Function(SplitError_EncodeError value) encodeError,
  }) {
    return cannotFit(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SplitError_Empty value)? empty,
    TResult? Function(SplitError_CannotFit value)? cannotFit,
    TResult? Function(SplitError_MaxSplitSizeTooLarge value)?
        maxSplitSizeTooLarge,
    TResult? Function(SplitError_MinSplitTooSmall value)? minSplitTooSmall,
    TResult? Function(SplitError_InvalidSplitRange value)? invalidSplitRange,
    TResult? Function(SplitError_InvalidVersionRange value)?
        invalidVersionRange,
    TResult? Function(SplitError_EncodeError value)? encodeError,
  }) {
    return cannotFit?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SplitError_Empty value)? empty,
    TResult Function(SplitError_CannotFit value)? cannotFit,
    TResult Function(SplitError_MaxSplitSizeTooLarge value)?
        maxSplitSizeTooLarge,
    TResult Function(SplitError_MinSplitTooSmall value)? minSplitTooSmall,
    TResult Function(SplitError_InvalidSplitRange value)? invalidSplitRange,
    TResult Function(SplitError_InvalidVersionRange value)? invalidVersionRange,
    TResult Function(SplitError_EncodeError value)? encodeError,
    required TResult orElse(),
  }) {
    if (cannotFit != null) {
      return cannotFit(this);
    }
    return orElse();
  }
}

abstract class SplitError_CannotFit extends SplitError {
  const factory SplitError_CannotFit() = _$SplitError_CannotFitImpl;
  const SplitError_CannotFit._() : super._();
}

/// @nodoc
abstract class _$$SplitError_MaxSplitSizeTooLargeImplCopyWith<$Res> {
  factory _$$SplitError_MaxSplitSizeTooLargeImplCopyWith(
          _$SplitError_MaxSplitSizeTooLargeImpl value,
          $Res Function(_$SplitError_MaxSplitSizeTooLargeImpl) then) =
      __$$SplitError_MaxSplitSizeTooLargeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$SplitError_MaxSplitSizeTooLargeImplCopyWithImpl<$Res>
    extends _$SplitErrorCopyWithImpl<$Res,
        _$SplitError_MaxSplitSizeTooLargeImpl>
    implements _$$SplitError_MaxSplitSizeTooLargeImplCopyWith<$Res> {
  __$$SplitError_MaxSplitSizeTooLargeImplCopyWithImpl(
      _$SplitError_MaxSplitSizeTooLargeImpl _value,
      $Res Function(_$SplitError_MaxSplitSizeTooLargeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$SplitError_MaxSplitSizeTooLargeImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$SplitError_MaxSplitSizeTooLargeImpl
    extends SplitError_MaxSplitSizeTooLarge {
  const _$SplitError_MaxSplitSizeTooLargeImpl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'SplitError.maxSplitSizeTooLarge(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SplitError_MaxSplitSizeTooLargeImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SplitError_MaxSplitSizeTooLargeImplCopyWith<
          _$SplitError_MaxSplitSizeTooLargeImpl>
      get copyWith => __$$SplitError_MaxSplitSizeTooLargeImplCopyWithImpl<
          _$SplitError_MaxSplitSizeTooLargeImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() cannotFit,
    required TResult Function(int field0) maxSplitSizeTooLarge,
    required TResult Function() minSplitTooSmall,
    required TResult Function() invalidSplitRange,
    required TResult Function() invalidVersionRange,
    required TResult Function(EncodeError field0) encodeError,
  }) {
    return maxSplitSizeTooLarge(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? cannotFit,
    TResult? Function(int field0)? maxSplitSizeTooLarge,
    TResult? Function()? minSplitTooSmall,
    TResult? Function()? invalidSplitRange,
    TResult? Function()? invalidVersionRange,
    TResult? Function(EncodeError field0)? encodeError,
  }) {
    return maxSplitSizeTooLarge?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? cannotFit,
    TResult Function(int field0)? maxSplitSizeTooLarge,
    TResult Function()? minSplitTooSmall,
    TResult Function()? invalidSplitRange,
    TResult Function()? invalidVersionRange,
    TResult Function(EncodeError field0)? encodeError,
    required TResult orElse(),
  }) {
    if (maxSplitSizeTooLarge != null) {
      return maxSplitSizeTooLarge(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SplitError_Empty value) empty,
    required TResult Function(SplitError_CannotFit value) cannotFit,
    required TResult Function(SplitError_MaxSplitSizeTooLarge value)
        maxSplitSizeTooLarge,
    required TResult Function(SplitError_MinSplitTooSmall value)
        minSplitTooSmall,
    required TResult Function(SplitError_InvalidSplitRange value)
        invalidSplitRange,
    required TResult Function(SplitError_InvalidVersionRange value)
        invalidVersionRange,
    required TResult Function(SplitError_EncodeError value) encodeError,
  }) {
    return maxSplitSizeTooLarge(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SplitError_Empty value)? empty,
    TResult? Function(SplitError_CannotFit value)? cannotFit,
    TResult? Function(SplitError_MaxSplitSizeTooLarge value)?
        maxSplitSizeTooLarge,
    TResult? Function(SplitError_MinSplitTooSmall value)? minSplitTooSmall,
    TResult? Function(SplitError_InvalidSplitRange value)? invalidSplitRange,
    TResult? Function(SplitError_InvalidVersionRange value)?
        invalidVersionRange,
    TResult? Function(SplitError_EncodeError value)? encodeError,
  }) {
    return maxSplitSizeTooLarge?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SplitError_Empty value)? empty,
    TResult Function(SplitError_CannotFit value)? cannotFit,
    TResult Function(SplitError_MaxSplitSizeTooLarge value)?
        maxSplitSizeTooLarge,
    TResult Function(SplitError_MinSplitTooSmall value)? minSplitTooSmall,
    TResult Function(SplitError_InvalidSplitRange value)? invalidSplitRange,
    TResult Function(SplitError_InvalidVersionRange value)? invalidVersionRange,
    TResult Function(SplitError_EncodeError value)? encodeError,
    required TResult orElse(),
  }) {
    if (maxSplitSizeTooLarge != null) {
      return maxSplitSizeTooLarge(this);
    }
    return orElse();
  }
}

abstract class SplitError_MaxSplitSizeTooLarge extends SplitError {
  const factory SplitError_MaxSplitSizeTooLarge(final int field0) =
      _$SplitError_MaxSplitSizeTooLargeImpl;
  const SplitError_MaxSplitSizeTooLarge._() : super._();

  int get field0;
  @JsonKey(ignore: true)
  _$$SplitError_MaxSplitSizeTooLargeImplCopyWith<
          _$SplitError_MaxSplitSizeTooLargeImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SplitError_MinSplitTooSmallImplCopyWith<$Res> {
  factory _$$SplitError_MinSplitTooSmallImplCopyWith(
          _$SplitError_MinSplitTooSmallImpl value,
          $Res Function(_$SplitError_MinSplitTooSmallImpl) then) =
      __$$SplitError_MinSplitTooSmallImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SplitError_MinSplitTooSmallImplCopyWithImpl<$Res>
    extends _$SplitErrorCopyWithImpl<$Res, _$SplitError_MinSplitTooSmallImpl>
    implements _$$SplitError_MinSplitTooSmallImplCopyWith<$Res> {
  __$$SplitError_MinSplitTooSmallImplCopyWithImpl(
      _$SplitError_MinSplitTooSmallImpl _value,
      $Res Function(_$SplitError_MinSplitTooSmallImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SplitError_MinSplitTooSmallImpl extends SplitError_MinSplitTooSmall {
  const _$SplitError_MinSplitTooSmallImpl() : super._();

  @override
  String toString() {
    return 'SplitError.minSplitTooSmall()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SplitError_MinSplitTooSmallImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() cannotFit,
    required TResult Function(int field0) maxSplitSizeTooLarge,
    required TResult Function() minSplitTooSmall,
    required TResult Function() invalidSplitRange,
    required TResult Function() invalidVersionRange,
    required TResult Function(EncodeError field0) encodeError,
  }) {
    return minSplitTooSmall();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? cannotFit,
    TResult? Function(int field0)? maxSplitSizeTooLarge,
    TResult? Function()? minSplitTooSmall,
    TResult? Function()? invalidSplitRange,
    TResult? Function()? invalidVersionRange,
    TResult? Function(EncodeError field0)? encodeError,
  }) {
    return minSplitTooSmall?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? cannotFit,
    TResult Function(int field0)? maxSplitSizeTooLarge,
    TResult Function()? minSplitTooSmall,
    TResult Function()? invalidSplitRange,
    TResult Function()? invalidVersionRange,
    TResult Function(EncodeError field0)? encodeError,
    required TResult orElse(),
  }) {
    if (minSplitTooSmall != null) {
      return minSplitTooSmall();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SplitError_Empty value) empty,
    required TResult Function(SplitError_CannotFit value) cannotFit,
    required TResult Function(SplitError_MaxSplitSizeTooLarge value)
        maxSplitSizeTooLarge,
    required TResult Function(SplitError_MinSplitTooSmall value)
        minSplitTooSmall,
    required TResult Function(SplitError_InvalidSplitRange value)
        invalidSplitRange,
    required TResult Function(SplitError_InvalidVersionRange value)
        invalidVersionRange,
    required TResult Function(SplitError_EncodeError value) encodeError,
  }) {
    return minSplitTooSmall(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SplitError_Empty value)? empty,
    TResult? Function(SplitError_CannotFit value)? cannotFit,
    TResult? Function(SplitError_MaxSplitSizeTooLarge value)?
        maxSplitSizeTooLarge,
    TResult? Function(SplitError_MinSplitTooSmall value)? minSplitTooSmall,
    TResult? Function(SplitError_InvalidSplitRange value)? invalidSplitRange,
    TResult? Function(SplitError_InvalidVersionRange value)?
        invalidVersionRange,
    TResult? Function(SplitError_EncodeError value)? encodeError,
  }) {
    return minSplitTooSmall?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SplitError_Empty value)? empty,
    TResult Function(SplitError_CannotFit value)? cannotFit,
    TResult Function(SplitError_MaxSplitSizeTooLarge value)?
        maxSplitSizeTooLarge,
    TResult Function(SplitError_MinSplitTooSmall value)? minSplitTooSmall,
    TResult Function(SplitError_InvalidSplitRange value)? invalidSplitRange,
    TResult Function(SplitError_InvalidVersionRange value)? invalidVersionRange,
    TResult Function(SplitError_EncodeError value)? encodeError,
    required TResult orElse(),
  }) {
    if (minSplitTooSmall != null) {
      return minSplitTooSmall(this);
    }
    return orElse();
  }
}

abstract class SplitError_MinSplitTooSmall extends SplitError {
  const factory SplitError_MinSplitTooSmall() =
      _$SplitError_MinSplitTooSmallImpl;
  const SplitError_MinSplitTooSmall._() : super._();
}

/// @nodoc
abstract class _$$SplitError_InvalidSplitRangeImplCopyWith<$Res> {
  factory _$$SplitError_InvalidSplitRangeImplCopyWith(
          _$SplitError_InvalidSplitRangeImpl value,
          $Res Function(_$SplitError_InvalidSplitRangeImpl) then) =
      __$$SplitError_InvalidSplitRangeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SplitError_InvalidSplitRangeImplCopyWithImpl<$Res>
    extends _$SplitErrorCopyWithImpl<$Res, _$SplitError_InvalidSplitRangeImpl>
    implements _$$SplitError_InvalidSplitRangeImplCopyWith<$Res> {
  __$$SplitError_InvalidSplitRangeImplCopyWithImpl(
      _$SplitError_InvalidSplitRangeImpl _value,
      $Res Function(_$SplitError_InvalidSplitRangeImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SplitError_InvalidSplitRangeImpl extends SplitError_InvalidSplitRange {
  const _$SplitError_InvalidSplitRangeImpl() : super._();

  @override
  String toString() {
    return 'SplitError.invalidSplitRange()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SplitError_InvalidSplitRangeImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() cannotFit,
    required TResult Function(int field0) maxSplitSizeTooLarge,
    required TResult Function() minSplitTooSmall,
    required TResult Function() invalidSplitRange,
    required TResult Function() invalidVersionRange,
    required TResult Function(EncodeError field0) encodeError,
  }) {
    return invalidSplitRange();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? cannotFit,
    TResult? Function(int field0)? maxSplitSizeTooLarge,
    TResult? Function()? minSplitTooSmall,
    TResult? Function()? invalidSplitRange,
    TResult? Function()? invalidVersionRange,
    TResult? Function(EncodeError field0)? encodeError,
  }) {
    return invalidSplitRange?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? cannotFit,
    TResult Function(int field0)? maxSplitSizeTooLarge,
    TResult Function()? minSplitTooSmall,
    TResult Function()? invalidSplitRange,
    TResult Function()? invalidVersionRange,
    TResult Function(EncodeError field0)? encodeError,
    required TResult orElse(),
  }) {
    if (invalidSplitRange != null) {
      return invalidSplitRange();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SplitError_Empty value) empty,
    required TResult Function(SplitError_CannotFit value) cannotFit,
    required TResult Function(SplitError_MaxSplitSizeTooLarge value)
        maxSplitSizeTooLarge,
    required TResult Function(SplitError_MinSplitTooSmall value)
        minSplitTooSmall,
    required TResult Function(SplitError_InvalidSplitRange value)
        invalidSplitRange,
    required TResult Function(SplitError_InvalidVersionRange value)
        invalidVersionRange,
    required TResult Function(SplitError_EncodeError value) encodeError,
  }) {
    return invalidSplitRange(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SplitError_Empty value)? empty,
    TResult? Function(SplitError_CannotFit value)? cannotFit,
    TResult? Function(SplitError_MaxSplitSizeTooLarge value)?
        maxSplitSizeTooLarge,
    TResult? Function(SplitError_MinSplitTooSmall value)? minSplitTooSmall,
    TResult? Function(SplitError_InvalidSplitRange value)? invalidSplitRange,
    TResult? Function(SplitError_InvalidVersionRange value)?
        invalidVersionRange,
    TResult? Function(SplitError_EncodeError value)? encodeError,
  }) {
    return invalidSplitRange?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SplitError_Empty value)? empty,
    TResult Function(SplitError_CannotFit value)? cannotFit,
    TResult Function(SplitError_MaxSplitSizeTooLarge value)?
        maxSplitSizeTooLarge,
    TResult Function(SplitError_MinSplitTooSmall value)? minSplitTooSmall,
    TResult Function(SplitError_InvalidSplitRange value)? invalidSplitRange,
    TResult Function(SplitError_InvalidVersionRange value)? invalidVersionRange,
    TResult Function(SplitError_EncodeError value)? encodeError,
    required TResult orElse(),
  }) {
    if (invalidSplitRange != null) {
      return invalidSplitRange(this);
    }
    return orElse();
  }
}

abstract class SplitError_InvalidSplitRange extends SplitError {
  const factory SplitError_InvalidSplitRange() =
      _$SplitError_InvalidSplitRangeImpl;
  const SplitError_InvalidSplitRange._() : super._();
}

/// @nodoc
abstract class _$$SplitError_InvalidVersionRangeImplCopyWith<$Res> {
  factory _$$SplitError_InvalidVersionRangeImplCopyWith(
          _$SplitError_InvalidVersionRangeImpl value,
          $Res Function(_$SplitError_InvalidVersionRangeImpl) then) =
      __$$SplitError_InvalidVersionRangeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SplitError_InvalidVersionRangeImplCopyWithImpl<$Res>
    extends _$SplitErrorCopyWithImpl<$Res, _$SplitError_InvalidVersionRangeImpl>
    implements _$$SplitError_InvalidVersionRangeImplCopyWith<$Res> {
  __$$SplitError_InvalidVersionRangeImplCopyWithImpl(
      _$SplitError_InvalidVersionRangeImpl _value,
      $Res Function(_$SplitError_InvalidVersionRangeImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SplitError_InvalidVersionRangeImpl
    extends SplitError_InvalidVersionRange {
  const _$SplitError_InvalidVersionRangeImpl() : super._();

  @override
  String toString() {
    return 'SplitError.invalidVersionRange()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SplitError_InvalidVersionRangeImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() cannotFit,
    required TResult Function(int field0) maxSplitSizeTooLarge,
    required TResult Function() minSplitTooSmall,
    required TResult Function() invalidSplitRange,
    required TResult Function() invalidVersionRange,
    required TResult Function(EncodeError field0) encodeError,
  }) {
    return invalidVersionRange();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? cannotFit,
    TResult? Function(int field0)? maxSplitSizeTooLarge,
    TResult? Function()? minSplitTooSmall,
    TResult? Function()? invalidSplitRange,
    TResult? Function()? invalidVersionRange,
    TResult? Function(EncodeError field0)? encodeError,
  }) {
    return invalidVersionRange?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? cannotFit,
    TResult Function(int field0)? maxSplitSizeTooLarge,
    TResult Function()? minSplitTooSmall,
    TResult Function()? invalidSplitRange,
    TResult Function()? invalidVersionRange,
    TResult Function(EncodeError field0)? encodeError,
    required TResult orElse(),
  }) {
    if (invalidVersionRange != null) {
      return invalidVersionRange();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SplitError_Empty value) empty,
    required TResult Function(SplitError_CannotFit value) cannotFit,
    required TResult Function(SplitError_MaxSplitSizeTooLarge value)
        maxSplitSizeTooLarge,
    required TResult Function(SplitError_MinSplitTooSmall value)
        minSplitTooSmall,
    required TResult Function(SplitError_InvalidSplitRange value)
        invalidSplitRange,
    required TResult Function(SplitError_InvalidVersionRange value)
        invalidVersionRange,
    required TResult Function(SplitError_EncodeError value) encodeError,
  }) {
    return invalidVersionRange(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SplitError_Empty value)? empty,
    TResult? Function(SplitError_CannotFit value)? cannotFit,
    TResult? Function(SplitError_MaxSplitSizeTooLarge value)?
        maxSplitSizeTooLarge,
    TResult? Function(SplitError_MinSplitTooSmall value)? minSplitTooSmall,
    TResult? Function(SplitError_InvalidSplitRange value)? invalidSplitRange,
    TResult? Function(SplitError_InvalidVersionRange value)?
        invalidVersionRange,
    TResult? Function(SplitError_EncodeError value)? encodeError,
  }) {
    return invalidVersionRange?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SplitError_Empty value)? empty,
    TResult Function(SplitError_CannotFit value)? cannotFit,
    TResult Function(SplitError_MaxSplitSizeTooLarge value)?
        maxSplitSizeTooLarge,
    TResult Function(SplitError_MinSplitTooSmall value)? minSplitTooSmall,
    TResult Function(SplitError_InvalidSplitRange value)? invalidSplitRange,
    TResult Function(SplitError_InvalidVersionRange value)? invalidVersionRange,
    TResult Function(SplitError_EncodeError value)? encodeError,
    required TResult orElse(),
  }) {
    if (invalidVersionRange != null) {
      return invalidVersionRange(this);
    }
    return orElse();
  }
}

abstract class SplitError_InvalidVersionRange extends SplitError {
  const factory SplitError_InvalidVersionRange() =
      _$SplitError_InvalidVersionRangeImpl;
  const SplitError_InvalidVersionRange._() : super._();
}

/// @nodoc
abstract class _$$SplitError_EncodeErrorImplCopyWith<$Res> {
  factory _$$SplitError_EncodeErrorImplCopyWith(
          _$SplitError_EncodeErrorImpl value,
          $Res Function(_$SplitError_EncodeErrorImpl) then) =
      __$$SplitError_EncodeErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({EncodeError field0});

  $EncodeErrorCopyWith<$Res> get field0;
}

/// @nodoc
class __$$SplitError_EncodeErrorImplCopyWithImpl<$Res>
    extends _$SplitErrorCopyWithImpl<$Res, _$SplitError_EncodeErrorImpl>
    implements _$$SplitError_EncodeErrorImplCopyWith<$Res> {
  __$$SplitError_EncodeErrorImplCopyWithImpl(
      _$SplitError_EncodeErrorImpl _value,
      $Res Function(_$SplitError_EncodeErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$SplitError_EncodeErrorImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as EncodeError,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $EncodeErrorCopyWith<$Res> get field0 {
    return $EncodeErrorCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$SplitError_EncodeErrorImpl extends SplitError_EncodeError {
  const _$SplitError_EncodeErrorImpl(this.field0) : super._();

  @override
  final EncodeError field0;

  @override
  String toString() {
    return 'SplitError.encodeError(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SplitError_EncodeErrorImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SplitError_EncodeErrorImplCopyWith<_$SplitError_EncodeErrorImpl>
      get copyWith => __$$SplitError_EncodeErrorImplCopyWithImpl<
          _$SplitError_EncodeErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() cannotFit,
    required TResult Function(int field0) maxSplitSizeTooLarge,
    required TResult Function() minSplitTooSmall,
    required TResult Function() invalidSplitRange,
    required TResult Function() invalidVersionRange,
    required TResult Function(EncodeError field0) encodeError,
  }) {
    return encodeError(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? cannotFit,
    TResult? Function(int field0)? maxSplitSizeTooLarge,
    TResult? Function()? minSplitTooSmall,
    TResult? Function()? invalidSplitRange,
    TResult? Function()? invalidVersionRange,
    TResult? Function(EncodeError field0)? encodeError,
  }) {
    return encodeError?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? cannotFit,
    TResult Function(int field0)? maxSplitSizeTooLarge,
    TResult Function()? minSplitTooSmall,
    TResult Function()? invalidSplitRange,
    TResult Function()? invalidVersionRange,
    TResult Function(EncodeError field0)? encodeError,
    required TResult orElse(),
  }) {
    if (encodeError != null) {
      return encodeError(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SplitError_Empty value) empty,
    required TResult Function(SplitError_CannotFit value) cannotFit,
    required TResult Function(SplitError_MaxSplitSizeTooLarge value)
        maxSplitSizeTooLarge,
    required TResult Function(SplitError_MinSplitTooSmall value)
        minSplitTooSmall,
    required TResult Function(SplitError_InvalidSplitRange value)
        invalidSplitRange,
    required TResult Function(SplitError_InvalidVersionRange value)
        invalidVersionRange,
    required TResult Function(SplitError_EncodeError value) encodeError,
  }) {
    return encodeError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SplitError_Empty value)? empty,
    TResult? Function(SplitError_CannotFit value)? cannotFit,
    TResult? Function(SplitError_MaxSplitSizeTooLarge value)?
        maxSplitSizeTooLarge,
    TResult? Function(SplitError_MinSplitTooSmall value)? minSplitTooSmall,
    TResult? Function(SplitError_InvalidSplitRange value)? invalidSplitRange,
    TResult? Function(SplitError_InvalidVersionRange value)?
        invalidVersionRange,
    TResult? Function(SplitError_EncodeError value)? encodeError,
  }) {
    return encodeError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SplitError_Empty value)? empty,
    TResult Function(SplitError_CannotFit value)? cannotFit,
    TResult Function(SplitError_MaxSplitSizeTooLarge value)?
        maxSplitSizeTooLarge,
    TResult Function(SplitError_MinSplitTooSmall value)? minSplitTooSmall,
    TResult Function(SplitError_InvalidSplitRange value)? invalidSplitRange,
    TResult Function(SplitError_InvalidVersionRange value)? invalidVersionRange,
    TResult Function(SplitError_EncodeError value)? encodeError,
    required TResult orElse(),
  }) {
    if (encodeError != null) {
      return encodeError(this);
    }
    return orElse();
  }
}

abstract class SplitError_EncodeError extends SplitError {
  const factory SplitError_EncodeError(final EncodeError field0) =
      _$SplitError_EncodeErrorImpl;
  const SplitError_EncodeError._() : super._();

  EncodeError get field0;
  @JsonKey(ignore: true)
  _$$SplitError_EncodeErrorImplCopyWith<_$SplitError_EncodeErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}
